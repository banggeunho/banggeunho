<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>웹 플랫폼 백엔드 아키텍처 개편 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo"><span class="logo-name">bang</span><span class="logo-dot">.geunho</span></a>
    <ul class="nav-links">
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#skills">Skills</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="웹 플랫폼 백엔드 아키텍처 개편">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>웹 플랫폼 백엔드 아키텍처 개편</h1>
        
        <div class="project-detail-tags">
          
            <span>NestJS</span>
          
            <span>AWS ECS</span>
          
            <span>MySQL 8.0</span>
          
            <span>Express</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD">배경: Express 모놀리식의 구조적 한계</a></li>
<li><a href="#%EC%99%9C-nestjs%EC%9D%B8%EA%B0%80">왜 NestJS인가</a></li>
<li><a href="#%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%A0%84%EB%9E%B5">마이그레이션 전략</a></li>
<li><a href="#%EC%84%A4%EA%B3%84-%EB%B0%8F-%EA%B5%AC%ED%98%84">설계 및 구현: 4-Layer 아키텍처</a></li>
<li><a href="#%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EA%B3%BC%EC%A0%95%EC%9D%98-%EC%B1%8C%EB%A6%B0%EC%A7%80">마이그레이션 과정의 챌린지</a></li>
<li><a href="#%EC%A3%BC%EC%9A%94-%EC%84%B1%EA%B3%BC">주요 성과</a></li>
<li><a href="#%EB%B0%B0%EC%9A%B4-%EC%A0%90">배운 점</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="개요">개요</h2>
<p>Express + SST 기반 모놀리식 서버를 NestJS로 마이그레이션하고, ECS 기반 컨테이너 배포 환경을 구축했습니다. 코드 컨벤션과 모듈 구조를 표준화하고, 개발 착수 전 아키텍처 공유 및 리뷰 프로세스를 도입했습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="배경">배경</h2>
<p>기존 시스템은 Express + SST 기반의 모놀리식 구조였습니다. 시간이 지나면서 다음과 같은 구조적 문제들이 누적되었습니다.</p>
<h3 id="기존-시스템의-문제">기존 시스템의 문제</h3>
<p><strong>프로젝트별 구조 파편화와 컨텍스트 스위칭 비용</strong> — 아키텍처 컨벤션이 명확하지 않은 상태에서 Express의 높은 자유도가 작용하여, 프로젝트마다 폴더 구조, 유틸/공통 코드 위치, 라우팅/서비스 레이어 분리 방식이 모두 달랐습니다. 개발자가 프로젝트를 전환할 때마다 해당 프로젝트의 구조를 새로 파악해야 했고, 특히 메인 서비스에서는 수월하게 개발 가능한 기능이 어드민에서는 구조 자체가 달라 별도의 아키텍처를 구상해야 하는 상황이 반복되었습니다.</p>
<p><strong>라우터에 밀집된 비즈니스 로직</strong> — 도메인별 계층 분리 없이 라우터 파일에 비즈니스 로직이 직접 구현되어 있었습니다. 어떤 API가 어떤 테이블에 데이터를 읽고 쓰는지 추적이 어려웠고, 하나의 수정이 예상치 못한 곳에 사이드이펙트를 일으키는 일이 빈번했습니다. 의존성 주입 없이 코드가 서로 엮이면서, 중복을 줄이기 위한 공통 코드가 자연스럽게 비대해지는 구조였습니다.</p>
<p><strong>합의 비용의 지속적 증가</strong> — Express에서도 컨벤션으로 통제는 가능하지만, 시스템이 발전할수록 신규 기능이나 예외 케이스가 발생할 때마다 <strong>컨벤션 작성 → 리뷰 → 팀 간 합의 → 문서화 과정을 반복</strong>해야 했습니다. 강제력이 없기 때문에 합의한 구조도 시간이 지나면 흐려지고, 동일한 문제가 반복되는 악순환이었습니다.</p>
<h3 id="마이그레이션-타이밍">마이그레이션 타이밍</h3>
<p>마침 기존 풀스택 개발 체제에서 프론트엔드/백엔드로 분야를 나누기로 결정한 시점이었습니다. 백엔드 팀이 독립적으로 기술 스택을 재정비할 수 있는 기회였고, 이 타이밍에 구조적 문제를 근본적으로 해결하고자 했습니다.</p>
<h3 id="왜-nestjs인가">왜 NestJS인가</h3>
<p>NestJS는 <strong>커뮤니티가 합의한 모범사례가 프레임워크에 내장</strong>되어 있어, 팀 내부에서 별도로 아키텍처를 재설계하고 합의하는 과정 없이 검증된 구조를 바로 활용할 수 있습니다. 기존에 겪었던 프로젝트별 구조 파편화, 컨텍스트 스위칭 비용, 합의 비용 문제를 프레임워크 레벨에서 해소할 수 있다고 판단했습니다.</p>
<p>또한 NestJS는 기본 HTTP 어댑터로 Express를 사용하기 때문에 기존 미들웨어와 에코시스템을 그대로 활용할 수 있어, 전환 비용도 합리적이었습니다. 학습 곡선에 대한 우려가 있었으나, 팀원들의 적극적인 학습 의지와 동의를 바탕으로 팀 내 공식 기술 스택으로 채택하였습니다.</p>
<h3 id="nestjs-도입의-장점">NestJS 도입의 장점</h3>
<p><strong>아키텍처의 통일성과 강제된 구조</strong> — NestJS는 Module - Controller - Service라는 명확한 3-tier 계층 구조를 강제합니다. 어떤 프로젝트를 보더라도 동일한 멘탈 모델이 적용되므로, NestJS를 조금만 학습해도 모든 프로젝트에 빠른 적응이 가능합니다. 표준화된 구조 덕분에 AI 코딩 도구(Cursor, GitHub Copilot 등)가 코드베이스를 이해하기 쉬워 더 정확한 코드 제안을 받을 수 있는 점도 이점이었습니다.</p>
<p><strong>온보딩 및 유지보수 개선</strong> — 기능을 모듈 단위로 나누고 의존성을 명시적으로 등록/주입하는 방식이라 코드의 책임과 경계가 명확합니다. Express의 경우 미들웨어, 유틸, 타입 등 다양한 폴더가 우후죽순으로 생겨나 몇 달만 지나도 코드 추적이 어려워지지만, NestJS는 프로젝트별 형태가 유사하여 팀원 이동이나 신규 입사 시 적응 속도가 빠릅니다.</p>
<p><strong>DI(Dependency Injection) 기반 설계</strong> — NestJS는 DI를 기본 제공하여 DB 클라이언트, 외부 API, 설정/로깅 등 공통 의존성을 주입 형태로 관리할 수 있습니다. 의존성 결합도가 낮아져 교체가 용이하고, 테스트에서 Mock 대체가 쉬워 단위 테스트 작성 및 자동 검증에 유리합니다. Express에서는 별도 DI 라이브러리(InversifyJS, Awilix 등)를 직접 도입하고 팀별 규칙을 정립해야 하므로 편차가 생기기 쉽습니다.</p>
<p><strong>모듈 단위 구성</strong> — 도메인/기능 단위로 모듈을 분리하고, <code>@Module</code> 데코레이터에 Controller/Provider/Entity를 명세서처럼 등록합니다. 모듈 파일만 보면 구성 요소를 한눈에 파악할 수 있어, 여러 도메인이 동시에 커지는 커머스 서비스에서 확장과 변경 영향 범위 관리에 유리합니다.</p>
<p><strong>Express 생태계 호환</strong> — NestJS는 기본 HTTP 어댑터로 Express를 사용할 수 있어, 기존 Express 미들웨어와 에코시스템을 그대로 활용 가능합니다. 기존에 공통으로 제공하던 미들웨어/모듈을 NestJS 프로젝트에도 그대로 적용할 수 있었습니다.</p>
<p><strong>합리적인 성능 특성</strong> — 프레임워크 오버헤드에 대한 우려가 있었으나, 실제 운영 환경에서 주요 병목은 DB 쿼리와 외부 API 연계이며 프레임워크 자체의 오버헤드는 무의미한 수준입니다. 미미한 오버헤드를 위해 구조적 일관성과 장기적 유지보수성을 포기하는 것은 합리적이지 않다고 판단했습니다.</p>
</section>
<section class="content-section">
<h2 id="마이그레이션-전략">마이그레이션 전략</h2>
<h3 id="빅뱅-방식">빅뱅 방식</h3>
<p>기존 시스템이 서버사이드 템플릿 기반이었고, 도메인 구조를 새로 나누면서 기존 코드와 달라지는 부분이 광범위하여 빅뱅 방식으로 전환을 진행했습니다.</p>
<h3 id="모바일-우선-전환">모바일 우선 전환</h3>
<p>전체 서비스를 한 번에 마이그레이션하는 것이 아니라, <strong>모바일 서비스를 우선 대상으로 프론트엔드 팀과 함께 전환</strong>을 진행했습니다. 기존 운영 서비스는 유지하면서 모바일부터 NestJS 기반으로 새로 구축하는 방식입니다.</p>
</section>
<section class="content-section">
<h2 id="설계-및-구현">설계 및 구현</h2>
<h3 id="4-layer-아키텍처-설계">4-Layer 아키텍처 설계</h3>
<p>NestJS의 기본 Layered Architecture에 도메인 레이어를 추가한 <strong>Controller → Service → Domain → Repository</strong> 4계층 구조를 설계했습니다. 학생 대상 커머스 특성상 학생인증과 같은 복잡한 비즈니스 로직이 존재하여, Service 레이어와 별도로 Domain 레이어를 두어 핵심 비즈니스 규칙을 분리했습니다.</p>
<pre class="mermaid">graph TB
    A[Client] -->|HTTP Request| B[Controller]
    B -->|DTO| C[Service]
    C -->|도메인 객체| D[Domain]
    C -->|데이터 요청| E[Repository]
    E -->|DB 쿼리| F[(MySQL)]
    E -->|API 호출| G[외부 API]
    E -->|AWS 서비스| H[S3 / SQS 등]
    D -.->|순수 TypeScript<br/>외부 의존성 없음| D</pre><ul>
<li><strong>Controller</strong>: 요청/응답 처리, 유효성 검증</li>
<li><strong>Service</strong>: 유스케이스 조합, 트랜잭션 관리</li>
<li><strong>Domain</strong>: 핵심 비즈니스 로직 (학생인증, 주문 규칙 등) — 순수 TypeScript로만 구성</li>
<li><strong>Repository</strong>: 데이터 접근 계층 — DB 쿼리, 외부 API 호출, AWS 서비스 연동 등 외부 의존성을 집중</li>
</ul>
<p><strong>모듈 구성 예시:</strong></p>
<pre><code class="language-typescript">@Module({
  imports: [TypeOrmModule.forFeature([Order, OrderItem])],
  controllers: [OrderController],
  providers: [OrderService, OrderDomain, OrderRepository],
  exports: [OrderService],
})
export class OrderModule {}</code></pre><p>모듈 파일만 보면 해당 도메인의 구성 요소를 한눈에 파악할 수 있습니다.</p>
<p><strong>Domain 레이어 예시 (순수 TypeScript):</strong></p>
<pre><code class="language-typescript">export class OrderDomain {
  validateOrder(member: Member, product: Product, quantity: number): void {
    if (!member.isStudentVerified) {
      throw new BusinessException('학생인증이 필요합니다');
    }
    if (product.stock &lt; quantity) {
      throw new BusinessException('재고가 부족합니다');
    }
    if (quantity &gt; product.maxPurchaseLimit) {
      throw new BusinessException('최대 구매 수량을 초과했습니다');
    }
  }

  calculateOrderAmount(product: Product, quantity: number): number {
    const baseAmount = product.price * quantity;
    return product.hasStudentDiscount
      ? baseAmount * (1 - product.studentDiscountRate)
      : baseAmount;
  }
}</code></pre><p>외부 의존성 없이 순수 TypeScript로만 구성되어 있어, Mock 없이도 안정적인 단위 테스트가 가능합니다.</p>
<p>핵심 설계 원칙은 <strong>Domain 레이어를 순수 TypeScript로 유지</strong>하는 것이었습니다. 외부 의존성이 없기 때문에 안정적인 단위 테스트가 가능하고, 비즈니스 규칙의 변경이 인프라 계층에 영향을 주지 않습니다.</p>
<h4 id="도메인-순수성과-데이터-페칭의-트레이드오프">도메인 순수성과 데이터 페칭의 트레이드오프</h4>
<p>다만 Domain 레이어를 순수하게 유지하면서 현실적인 어려움이 있었습니다. 도메인이 비즈니스 규칙을 판단하려면 <strong>필요한 데이터가 미리 모두 준비되어야</strong> 합니다. 예를 들어 주문 가능 여부를 판단하려면 회원 정보, 학생인증 상태, 상품 재고 등을 Service 레이어가 사전에 조회해서 Domain에 넘겨줘야 하므로, 일부 오버페칭이 발생할 수밖에 없었습니다.</p>
<p>이를 도메인별 특성에 맞게 실용적으로 접근했습니다. 복잡한 비즈니스 규칙이 있는 도메인(학생인증, 주문 등)은 순수 Domain 레이어를 활용하되, Repository 레이어의 쿼리 최적화로 불필요한 데이터 조회를 최소화했습니다. 도메인 순수성의 원칙이 최대한 깨지지 않는 선에서 안정적인 테스트 환경을 확보하는 것을 우선했습니다.</p>
<h3 id="코드-컨벤션과-리뷰-프로세스">코드 컨벤션과 리뷰 프로세스</h3>
<p>처음부터 완벽한 컨벤션을 정의하기보다, <strong>코드 리뷰를 통해 점진적으로 팀 스타일을 맞춰갔습니다.</strong> 순환참조 발생 시 해결 방식, 분리가 애매한 도메인의 경계 설정, 새로운 패턴에 대한 의견 개진 등 실제 코드를 작성하면서 부딪히는 문제들을 리뷰 과정에서 합의하고 컨벤션으로 정립했습니다.</p>
<h3 id="ecs-기반-배포-환경">ECS 기반 배포 환경</h3>
<ul>
<li>AWS ECS 컨테이너 배포 환경 구축</li>
<li>유휴 리소스 활용으로 QA 서버를 ECS로 분리/증설</li>
<li>병렬 배포 구조 도입으로 배포 병목 해소</li>
</ul>
</section>
<section class="content-section">
<h2 id="마이그레이션-과정의-챌린지">마이그레이션 과정의 챌린지</h2>
<h3 id="기존-코드의-완전한-이해">기존 코드의 완전한 이해</h3>
<p>마이그레이션의 전제 조건은 기존 코드를 완벽하게 이해하는 것이었습니다. Express의 미들웨어와 비즈니스 로직이 여기저기 흩어져 있다 보니, <strong>기존 기능을 누락하지 않고 전환하는 것 자체가 큰 도전</strong>이었습니다. 하나로 모을 수 있는 로직은 통합하고, 분리해야 할 것은 분리하는 재구조화 작업이 상당했으며, 이 과정에서 <strong>TDD 방식이 기존 기능의 동작을 보장하는 안전망</strong> 역할을 했습니다.</p>
<h3 id="팀-내-학습-곡선-극복">팀 내 학습 곡선 극복</h3>
<p>주 1회 내가 작업한 부분을 팀에 공유하는 시간을 가졌습니다. 단순히 결과만 공유하는 것이 아니라, <strong>왜 이렇게 설계했는지, 다른 방식으로 했을 때 어떤 불편함이 있었는지</strong> 등 의사결정 과정을 함께 나눴습니다. 이외에도 NestJS 관련 아티클 공유와 스터디를 병행하며 팀 전체의 이해도를 높여갔습니다.</p>
</section>
<section class="content-section">
<h2 id="주요-성과">주요 성과</h2>
<ul>
<li><strong>실 서비스 배포 완료</strong>: NestJS 기반 서버가 실제 운영 환경에 배포되어 안정적으로 운영 중이며, 전환 과정에서 축적한 노하우가 팀 자산으로 남았습니다</li>
<li><strong>기술 부채 해소</strong>: 라우터에 밀집되어 있던 비즈니스 로직이 도메인별, 기능별로 수직 분리되어 유지보수성이 크게 개선되었습니다</li>
<li><strong>코드 리뷰 및 유지보수 비용 감소</strong>: 프레임워크가 강제하는 일관된 구조 덕분에 개발자마다 코드 스타일이 조금씩 달라도 전체적인 틀에서 크게 벗어나지 않아, 코드 리뷰 속도와 유지보수 비용이 확연히 줄었습니다</li>
<li><strong>QA 환경 병렬 배포로 배포 대기시간 제거</strong></li>
<li><strong>ISMS-P 인증 심사 대응 및 보안 조치 수행</strong></li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<h3 id="1-프레임워크의-강제력이-곧-생산성이다">1. 프레임워크의 강제력이 곧 생산성이다</h3>
<p>Express의 자유도가 높다는 것은 장점이자 단점이었습니다. 프로젝트 초기에는 빠르게 개발할 수 있지만, 시스템이 커지면서 &quot;자유&quot;가 &quot;혼란&quot;이 됩니다. NestJS의 강제된 구조는 초기에는 번거로워 보이지만, 장기적으로 팀 전체의 생산성을 높이는 기반이 되었습니다.</p>
<h3 id="2-도메인-순수성은-타협의-예술이다">2. 도메인 순수성은 타협의 예술이다</h3>
<p>Domain 레이어를 순수 TypeScript로 유지하겠다는 원칙은 이상적이지만, 현실에서는 데이터 페칭과의 트레이드오프가 존재합니다. 원칙을 100% 지키는 것보다, <strong>원칙을 이해한 상태에서 실용적으로 타협하는 것</strong>이 더 중요했습니다.</p>
<h3 id="3-마이그레이션은-코드-전환이-아니라-재설계다">3. 마이그레이션은 코드 전환이 아니라 재설계다</h3>
<p>기존 코드를 단순히 NestJS 문법으로 옮기는 것이 아니라, 도메인을 다시 분석하고 계층을 재설계하는 과정이었습니다. TDD가 이 과정에서 기존 기능의 안전망 역할을 했고, 코드 리뷰가 팀의 아키텍처 이해도를 높이는 학습 도구가 되었습니다.</p>
<h3 id="4-기술-도입은-팀의-합의가-전제다">4. 기술 도입은 팀의 합의가 전제다</h3>
<p>NestJS 도입 과정에서 학습 곡선에 대한 우려가 있었지만, 팀원들의 적극적인 학습 의지가 있었기에 가능했습니다. 주 1회 공유 세션과 스터디를 통해 의사결정 과정을 투명하게 나누는 것이 기술 도입의 성패를 좌우했습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="기술-스택">기술 스택</h2>
<table>
<thead>
<tr>
<th>분류</th>
<th>기술</th>
</tr>
</thead>
<tbody><tr>
<td><strong>백엔드 프레임워크</strong></td>
<td>NestJS (TypeScript)</td>
</tr>
<tr>
<td><strong>기존 프레임워크</strong></td>
<td>Express + SST</td>
</tr>
<tr>
<td><strong>데이터베이스</strong></td>
<td>MySQL 8.0</td>
</tr>
<tr>
<td><strong>배포 환경</strong></td>
<td>AWS ECS (Fargate)</td>
</tr>
<tr>
<td><strong>테스트</strong></td>
<td>Jest (TDD)</td>
</tr>
</tbody></table>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2025 Geunho Bang</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#22C55E',
        primaryTextColor: '#F8FAFC',
        primaryBorderColor: '#334155',
        lineColor: '#64748B',
        secondaryColor: '#1E293B',
        tertiaryColor: '#0F172A',
        background: '#0F172A',
        mainBkg: '#1E293B',
        secondBkg: '#334155',
        border1: '#334155',
        border2: '#475569',
        note: '#1E293B',
        noteBkg: '#1E293B',
        noteBorder: '#334155',
        noteText: '#F8FAFC',
        fontSize: '14px',
        fontFamily: 'IBM Plex Sans, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
