<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>토스페이 결제 시스템 연동 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo">GB</a>
    <ul class="nav-links">
      <li><a href="../../index.html#about">About</a></li>
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#contact">Contact</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="토스페이 결제 시스템 연동">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>토스페이 결제 시스템 연동</h1>
        
        <div class="project-detail-tags">
          
            <span>TossPay</span>
          
            <span>Payment</span>
          
            <span>NestJS</span>
          
            <span>MySQL</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%ED%95%A9%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EA%B2%B0%EC%A0%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C">배경: 데이터 정합성을 고려한 결제 시스템</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-4%EA%B0%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%8F%99%EC%8B%9C-%EA%B0%9C%EB%B0%9C">문제 분석: 4개 시스템의 동시 개발</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%AA%A9%ED%91%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EB%8B%AC%EC%84%B1%ED%95%98%EB%A0%A4-%ED%96%88%EB%82%98">해결 목표: 무엇을 달성하려 했나</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EB%B3%B4%EC%83%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0">아키텍처 설계: 이벤트 기반 보상 트랜잭션 선택 이유</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-%EB%B3%91%EB%A0%AC-%EA%B0%9C%EB%B0%9C-%EC%A0%84%EB%9E%B5">핵심 구현 1: 병렬 개발 전략</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EB%B3%B4%EC%83%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%ED%95%A9%EC%84%B1-%EB%B3%B4%EC%9E%A5">핵심 구현 2: 이벤트 기반 보상 트랜잭션으로 데이터 정합성 보장</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-%EC%88%AB%EC%9E%90%EB%A1%9C-%EC%A6%9D%EB%AA%85%ED%95%98%EB%8A%94-%EA%B0%9C%EC%84%A0-%ED%9A%A8%EA%B3%BC">결과: 숫자로 증명하는 개선 효과</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-데이터-정합성을-고려한-결제-시스템">배경: 데이터 정합성을 고려한 결제 시스템</h2>
<p>&quot;토스페이 결제를 추가해주세요.&quot;</p>
<p>커머스 플랫폼에 신규 결제 수단을 추가하는 작업. 단순해 보이지만, 결제-주문-정산 시스템 간 데이터 정합성을 보장하는 것이 핵심 과제였습니다. 토스 생태계와의 연동으로 신규 고객을 유입하고, 결제 수단 다양화로 결제 성공률을 개선해야 했습니다.</p>
<p><strong>가장 중요하게 고민한 것은 안전성이었습니다.</strong> 결제는 승인됐는데 주문이 실패하면? 주문은 생성됐는데 정산 데이터가 누락되면? 네트워크 장애로 중복 결제가 발생하면? 이런 모든 시나리오를 사전에 설계하고 대응 방안을 마련하는 데 집중했습니다.</p>
<p>결과적으로 이 프로젝트는 **전체 거래액의 30%(111억 원)**를 토스페이가 차지하는 성공으로 이어졌습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-4개-시스템의-동시-개발">문제 분석: 4개 시스템의 동시 개발</h2>
<p>결제 시스템은 단순히 &quot;결제 버튼 클릭 → 승인&quot; 으로 끝나지 않습니다. 실제로는 4개의 독립적인 시스템이 유기적으로 동작해야 합니다.</p>
<h3 id="영향을-받는-시스템">영향을 받는 시스템</h3>
<p><strong>1. 결제 시스템</strong></p>
<ul>
<li>토스페이 API 연동 (인증, 승인, 취소, 환불)</li>
<li>기존 PG(이니시스, 카카오페이)와 라우팅 로직 통합</li>
<li>Webhook 수신 및 처리</li>
</ul>
<p><strong>2. 주문 시스템</strong></p>
<ul>
<li>결제 완료 → 주문 생성 플로우</li>
<li>결제 실패 시 주문 롤백</li>
<li>주문 상태 관리 (결제 대기 → 결제 완료 → 배송 준비)</li>
</ul>
<p><strong>3. 정산 시스템</strong></p>
<ul>
<li>토스페이 수수료 정책 반영</li>
<li>일별/월별 정산 데이터 집계</li>
<li>정산 내역 조회 및 엑셀 다운로드</li>
</ul>
<p><strong>4. 어드민 시스템</strong></p>
<ul>
<li>결제 내역 조회 및 필터링</li>
<li>수동 환불 처리</li>
<li>정산 대시보드 및 통계</li>
</ul>
<h3 id="왜-어려웠을까">왜 어려웠을까?</h3>
<p><strong>4개 시스템 동시 개발:</strong></p>
<ul>
<li>4개 시스템을 동시 개발하면 의존성 지옥 발생 가능</li>
<li>API 명세 불일치로 인한 통합 실패 리스크</li>
</ul>
<p><strong>데이터 정합성 보장:</strong></p>
<ul>
<li>결제는 승인됐는데 주문은 실패하면?</li>
<li>주문은 생성됐는데 정산 데이터가 누락되면?</li>
<li>네트워크 장애로 중복 요청이 들어오면?</li>
<li>이런 모든 예외 케이스를 사전에 설계하고 대응 방안 마련 필요</li>
</ul>
<p><strong>안전성과 확장성:</strong></p>
<ul>
<li>장애 발생 시 자동 복구 메커니즘</li>
<li>향후 다른 PG 추가 시에도 확장 가능한 구조</li>
<li>멱등성 보장으로 중복 처리 방지</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="해결-목표-무엇을-달성하려-했나">해결 목표: 무엇을 달성하려 했나</h2>
<p>우리는 명확한 목표를 설정했습니다.</p>
<h3 id="정량적-목표">정량적 목표</h3>
<ul>
<li><strong>결제 성공률</strong>: 95% 이상 유지</li>
<li><strong>데이터 정합성</strong>: 불일치 케이스 0건</li>
<li><strong>시스템 안정성</strong>: 자동 복구율 100%</li>
</ul>
<h3 id="정성적-목표">정성적 목표</h3>
<ul>
<li>4개 시스템을 병렬로 개발하되 블로킹 없이 진행</li>
<li>결제-주문-정산 전 과정의 데이터 일관성 보장</li>
<li>장애 발생 시 자동 보상 트랜잭션으로 복구</li>
<li>멱등성 보장으로 중복 처리 방지</li>
<li>확장 가능한 아키텍처 (향후 다른 PG 추가 용이)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-이벤트-기반-보상-트랜잭션-선택-이유">아키텍처 설계: 이벤트 기반 보상 트랜잭션 선택 이유</h2>
<h3 id="기존-pg-구조">기존 PG 구조</h3>
<pre class="mermaid">graph LR
    A[결제 요청] --> B{PG 라우팅}
    B -->|신용카드| C[이니시스]
    B -->|간편결제| D[카카오페이]
    C --> E[결제 승인]
    D --> E
    E --> F[주문 생성]
    F --> G[정산 데이터]</pre><h3 id="토스페이-추가-후-아키텍처">토스페이 추가 후 아키텍처</h3>
<pre class="mermaid">graph TB
    A[사용자] -->|결제 요청| B[Payment API]
    B --> C{PG 선택}
    C -->|신용카드| D[이니시스]
    C -->|카카오| E[카카오페이]
    C -->|토스| F[토스페이]

    F -->|승인| G[결제 완료]
    G -->|이벤트| H[주문 생성]
    H -->|성공| I[정산 데이터]

    G -.실패.-> J[자동 환불]
    H -.실패.-> J</pre><h3 id="이벤트-기반-보상-트랜잭션을-선택한-이유">이벤트 기반 보상 트랜잭션을 선택한 이유</h3>
<p><strong>문제 상황:</strong></p>
<ul>
<li>결제 승인은 성공했지만 주문 생성이 실패하는 경우</li>
<li>네트워크 장애로 정산 데이터 적재가 누락되는 경우</li>
<li>중복 요청으로 같은 주문에 대해 결제가 2번 승인되는 경우</li>
</ul>
<p><strong>해결책: 이벤트 기반 보상 트랜잭션</strong></p>
<ul>
<li>분산 트랜잭션을 여러 단계로 나누고, 각 단계마다 이벤트 발행</li>
<li>실패 시 보상 트랜잭션(Compensating Transaction) 자동 실행</li>
<li>각 단계가 독립적으로 동작하되, 전체 플로우의 데이터 일관성 보장</li>
<li>멱등성 키를 활용해 중복 처리 방지</li>
</ul>
<p><strong>설계 시 고려한 사항:</strong></p>
<ol>
<li><p><strong>자동 복구 메커니즘</strong></p>
<ul>
<li>주문 생성 실패 → 자동 환불 이벤트 발행</li>
<li>정산 데이터 누락 → 재시도 큐에 적재</li>
<li>네트워크 타임아웃 → 멱등성 키로 중복 방지</li>
</ul>
</li>
<li><p><strong>데이터 일관성 보장</strong></p>
<ul>
<li><code>payment_order_mapping</code> 테이블로 결제-주문 1:1 매핑</li>
<li>유니크 제약 조건으로 중복 결제 원천 차단</li>
<li>이벤트 로그 테이블로 전체 플로우 추적 가능</li>
</ul>
</li>
<li><p><strong>확장성 고려</strong></p>
<ul>
<li>새로운 PG 추가 시 이벤트 리스너만 추가하면 됨</li>
<li>정산/어드민 시스템이 독립적으로 이벤트 구독</li>
<li>시스템 간 강결합 없이 느슨한 결합 유지</li>
</ul>
</li>
</ol>
<p><strong>장점:</strong></p>
<table>
<thead>
<tr>
<th>기준</th>
<th>기존 방식</th>
<th>이벤트 기반 보상 트랜잭션</th>
</tr>
</thead>
<tbody><tr>
<td>트랜잭션 범위</td>
<td>단일 DB 트랜잭션</td>
<td>분산 트랜잭션</td>
</tr>
<tr>
<td>실패 처리</td>
<td>수동 롤백</td>
<td>자동 보상 트랜잭션</td>
</tr>
<tr>
<td>중복 처리 방지</td>
<td>애플리케이션 로직</td>
<td>멱등성 키 + DB 제약</td>
</tr>
<tr>
<td>확장성</td>
<td>제한적</td>
<td>높음</td>
</tr>
<tr>
<td>복잡도</td>
<td>낮음</td>
<td>중간</td>
</tr>
</tbody></table>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-병렬-개발-전략">핵심 구현 1: 병렬 개발 전략</h2>
<h3 id="도전-4개-시스템을-어떻게-동시-개발할까">도전: 4개 시스템을 어떻게 동시 개발할까?</h3>
<p><strong>문제:</strong></p>
<ul>
<li>결제 API가 완성되어야 주문 시스템 개발 가능?</li>
<li>아니면 모두가 완성될 때까지 기다려야 할까?</li>
</ul>
<p><strong>해결: API 인터페이스 선정의</strong></p>
<p>1단계에서 API 명세를 먼저 확정했습니다.</p>
<p><strong>결제 API 명세 (예시):</strong></p>
<pre><code class="language-typescript">// 결제 승인 요청
POST /payments/approve
{
  "paymentKey": "tosspay_xxx",
  "orderId": "order_123",
  "amount": 50000
}

// 응답
{
  "success": true,
  "paymentId": "pay_456",
  "status": "APPROVED",
  "approvedAt": "2024-09-01T10:00:00Z"
}</code></pre><p><strong>이벤트 스키마:</strong></p>
<pre><code class="language-typescript">// 결제 완료 이벤트
{
  "eventType": "PAYMENT_APPROVED",
  "paymentId": "pay_456",
  "orderId": "order_123",
  "amount": 50000,
  "pg": "TOSS"
}</code></pre><h3 id="병렬-개발-타임라인">병렬 개발 타임라인</h3>
<table>
<thead>
<tr>
<th>주차</th>
<th>결제팀 (본인)</th>
<th>주문팀 (동료A)</th>
<th>정산팀 (동료B)</th>
<th>어드민팀 (동료C)</th>
</tr>
</thead>
<tbody><tr>
<td>1-2주</td>
<td>토스페이 API 연동</td>
<td>이벤트 리스너 구현</td>
<td>정산 로직 설계</td>
<td>UI 설계</td>
</tr>
<tr>
<td>3-4주</td>
<td>Webhook 처리</td>
<td>주문 생성 로직</td>
<td>정산 데이터 적재</td>
<td>CRUD 구현</td>
</tr>
<tr>
<td>5주</td>
<td>통합 테스트</td>
<td>통합 테스트</td>
<td>통합 테스트</td>
<td>통합 테스트</td>
</tr>
<tr>
<td>6주</td>
<td>프로덕션 배포</td>
<td>프로덕션 배포</td>
<td>프로덕션 배포</td>
<td>프로덕션 배포</td>
</tr>
</tbody></table>
<p><strong>핵심:</strong></p>
<ul>
<li>API 명세가 확정되면 각 팀이 독립적으로 개발 가능</li>
<li>Mock 서버로 개발 진행 → 실제 통합은 5주차에 진행</li>
<li>생산성 2배 향상 (4개 시스템을 순차 개발하면 12주 소요)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-이벤트-기반-보상-트랜잭션으로-데이터-정합성-보장">핵심 구현 2: 이벤트 기반 보상 트랜잭션으로 데이터 정합성 보장</h2>
<h3 id="트랜잭션-플로우">트랜잭션 플로우</h3>
<p><strong>정상 플로우:</strong></p>
<pre><code class="language-">1. 결제 승인 요청
2. 토스페이 API 호출
3. 결제 승인 성공
4. 주문 생성 이벤트 발행
5. 주문 생성 성공
6. 정산 데이터 적재</code></pre><p><strong>실패 시 보상 트랜잭션:</strong></p>
<pre><code class="language-">1. 결제 승인 성공
2. 주문 생성 이벤트 발행
3. 주문 생성 실패 ❌
4. 자동 환불 이벤트 발행 🔄
5. 토스페이 환불 API 호출
6. 주문 상태 롤백</code></pre><h3 id="구현-코드-예시">구현 코드 (예시)</h3>
<p><strong>결제 승인 후 이벤트 발행:</strong></p>
<pre><code class="language-typescript">async approvePayment(dto: ApprovePaymentDto) {
  // 1. 토스페이 승인
  const approval = await this.tossPayService.approve(dto);

  // 2. DB에 결제 정보 저장
  const payment = await this.paymentRepository.save({
    paymentKey: approval.paymentKey,
    orderId: dto.orderId,
    amount: dto.amount,
    status: 'APPROVED',
    pg: 'TOSS'
  });

  // 3. 주문 생성 이벤트 발행
  await this.eventBus.publish(new PaymentApprovedEvent({
    paymentId: payment.id,
    orderId: dto.orderId,
    amount: dto.amount
  }));

  return payment;
}</code></pre><p><strong>주문 생성 실패 시 자동 환불:</strong></p>
<pre><code class="language-typescript">@EventHandler(OrderCreationFailedEvent)
async handleOrderCreationFailed(event: OrderCreationFailedEvent) {
  const payment = await this.paymentRepository.findOne(event.paymentId);

  // 자동 환불 처리
  await this.tossPayService.refund({
    paymentKey: payment.paymentKey,
    reason: '주문 생성 실패'
  });

  // 결제 상태 업데이트
  await this.paymentRepository.update(payment.id, {
    status: 'REFUNDED',
    refundReason: '주문 생성 실패'
  });
}</code></pre><h3 id="멱등성-보장">멱등성 보장</h3>
<p><strong>문제:</strong></p>
<ul>
<li>네트워크 장애로 중복 요청이 들어오면?</li>
<li>같은 주문에 대해 결제가 2번 승인되면?</li>
</ul>
<p><strong>해결: payment_order_mapping 테이블</strong></p>
<pre><code class="language-sql">CREATE TABLE payment_order_mapping (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  order_id VARCHAR(255) UNIQUE,  -- 주문 ID (유니크 제약)
  payment_id BIGINT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);</code></pre><pre><code class="language-typescript">// 주문 생성 전 중복 체크
const existing = await this.mappingRepository.findOne({
  orderId: dto.orderId
});

if (existing) {
  throw new ConflictException('이미 결제가 진행된 주문입니다');
}</code></pre><p><strong>토스페이 Webhook 멱등성:</strong></p>
<pre><code class="language-typescript">@Post('/webhook')
async handleWebhook(@Body() body: TossWebhookDto) {
  // 멱등성 키 검증
  const existing = await this.webhookLogRepository.findOne({
    paymentKey: body.paymentKey,
    eventType: body.eventType
  });

  if (existing) {
    return { success: true }; // 이미 처리됨
  }

  // Webhook 처리
  await this.processWebhook(body);

  // 로그 저장
  await this.webhookLogRepository.save({
    paymentKey: body.paymentKey,
    eventType: body.eventType
  });
}</code></pre><hr>
</section>
<section class="content-section">
<h2 id="결과-숫자로-증명하는-개선-효과">결과: 숫자로 증명하는 개선 효과</h2>
<h3 id="비즈니스-성과">비즈니스 성과</h3>
<table>
<thead>
<tr>
<th>지표</th>
<th>결과</th>
</tr>
</thead>
<tbody><tr>
<td><strong>거래액 비중</strong></td>
<td>전체의 30% (111억 원)</td>
</tr>
<tr>
<td><strong>결제 성공률</strong></td>
<td>96.5%</td>
</tr>
<tr>
<td><strong>데이터 정합성</strong></td>
<td>불일치 케이스 0건</td>
</tr>
<tr>
<td><strong>자동 복구율</strong></td>
<td>100% (보상 트랜잭션)</td>
</tr>
</tbody></table>
<h3 id="기술적-성과">기술적 성과</h3>
<p><strong>병렬 개발:</strong></p>
<ul>
<li>4개 시스템 동시 개발로 생산성 2배 향상</li>
<li>API 명세 선정의로 블로킹 없이 진행</li>
</ul>
<p><strong>이벤트 기반 보상 트랜잭션:</strong></p>
<ul>
<li>결제-주문-정산 데이터 정합성 100% 보장</li>
<li>자동 보상 트랜잭션으로 수동 롤백 작업 0건</li>
<li>멱등성 보장으로 중복 처리 방지</li>
</ul>
<h3 id="before-vs-after">Before vs After</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Before</th>
<th>After</th>
</tr>
</thead>
<tbody><tr>
<td>결제 수단</td>
<td>2개 (이니시스, 카카오페이)</td>
<td>3개 (토스페이 추가)</td>
</tr>
<tr>
<td>토스페이 거래액</td>
<td>0원</td>
<td>111억 원 (30%)</td>
</tr>
<tr>
<td>개발 방식</td>
<td>순차 개발</td>
<td>병렬 개발 (API 명세 선정의)</td>
</tr>
<tr>
<td>데이터 정합성</td>
<td>수동 체크</td>
<td>자동 보장 (보상 트랜잭션)</td>
</tr>
<tr>
<td>장애 복구</td>
<td>수동 처리</td>
<td>자동 복구 (이벤트 기반)</td>
</tr>
</tbody></table>
<hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<p><strong>1. 병렬 개발의 핵심은 API 명세</strong></p>
<ul>
<li>인터페이스만 확정되면 각 팀이 독립적으로 개발 가능</li>
<li>Mock 서버로 개발 → 실제 통합은 마지막에</li>
<li>개발 속도 2배 향상</li>
</ul>
<p><strong>2. 안전성 고려가 설계의 시작점</strong></p>
<ul>
<li>&quot;결제는 승인됐는데 주문은 실패하면?&quot;부터 시작</li>
<li>모든 예외 케이스를 사전에 도출하고 대응 방안 설계</li>
<li>이벤트 기반 보상 트랜잭션으로 자동 복구 메커니즘 구축</li>
</ul>
<p><strong>3. 이벤트 기반 아키텍처의 장점</strong></p>
<ul>
<li>결제 시스템은 여러 독립적인 시스템으로 구성</li>
<li>각 시스템이 이벤트로 느슨하게 결합</li>
<li>실패 시 보상 트랜잭션으로 데이터 정합성 자동 보장</li>
<li>새로운 시스템 추가 시 이벤트 리스너만 구현하면 됨</li>
</ul>
<p><strong>4. 멱등성은 선택이 아닌 필수</strong></p>
<ul>
<li>네트워크 장애는 언제든 발생 가능</li>
<li>중복 요청을 막지 못하면 결제 2중 처리 발생</li>
<li><code>payment_order_mapping</code> 테이블의 유니크 제약으로 DB 레벨에서 보장</li>
<li>토스페이 Webhook도 <code>paymentKey</code>로 멱등성 검증</li>
</ul>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2025 Geunho Bang. Built with passion.</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#0366d6',
        primaryTextColor: '#24292e',
        primaryBorderColor: '#e1e4e8',
        lineColor: '#586069',
        secondaryColor: '#f6f8fa',
        tertiaryColor: '#fafbfc',
        background: '#ffffff',
        mainBkg: '#ffffff',
        secondBkg: '#f6f8fa',
        border1: '#e1e4e8',
        border2: '#e1e4e8',
        note: '#fff5b1',
        noteBkg: '#fff5b1',
        noteBorder: '#e1e4e8',
        noteText: '#24292e',
        fontSize: '14px',
        fontFamily: 'Inter, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
