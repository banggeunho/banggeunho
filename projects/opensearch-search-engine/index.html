<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>검색 엔진 전면 개편 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo"><span class="logo-name">bang</span><span class="logo-dot">.geunho</span></a>
    <ul class="nav-links">
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#skills">Skills</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="검색 엔진 전면 개편">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>검색 엔진 전면 개편</h1>
        
        <div class="project-detail-tags">
          
            <span>AWS OpenSearch</span>
          
            <span>NestJS</span>
          
            <span>Redis</span>
          
            <span>Lambda</span>
          
            <span>Redshift</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%EB%8A%90%EB%A6%B0-%EA%B2%80%EC%83%89-%EB%B6%88%EC%95%88%EC%A0%95%ED%95%9C-%EC%84%9C%EB%B2%84">배경: 느린 검색, 불안정한 서버</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-fusejs%EC%9D%98-%ED%95%9C%EA%B3%84">문제 분석: Fuse.js의 한계</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%AA%A9%ED%91%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EB%8B%AC%EC%84%B1%ED%95%98%EB%A0%A4-%ED%96%88%EB%82%98">해결 목표: 무엇을 달성하려 했나</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-opensearch%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0">아키텍처 설계: OpenSearch를 선택한 이유</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-ctr-%EA%B8%B0%EB%B0%98-%EB%8F%99%EC%A0%81-%EB%9E%AD%ED%82%B9">핵심 구현 1: CTR 기반 동적 랭킹</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-%EC%BA%90%EC%8B%9C-%EC%A0%84%EB%9E%B5%EC%9C%BC%EB%A1%9C-%EC%9D%91%EB%8B%B5-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0">핵심 구현 2: 캐시 전략으로 응답 속도 개선</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-3-%EB%B0%B0%ED%8F%AC-%EC%97%86%EC%9D%B4-%EA%B2%80%EC%83%89-%ED%92%88%EC%A7%88-%EA%B0%9C%EC%84%A0">핵심 구현 3: 배포 없이 검색 품질 개선</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-%EC%88%AB%EC%9E%90%EB%A1%9C-%EC%A6%9D%EB%AA%85%ED%95%98%EB%8A%94-%EA%B0%9C%EC%84%A0-%ED%9A%A8%EA%B3%BC">결과: 숫자로 증명하는 개선 효과</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-느린-검색-불안정한-서버">배경: 느린 검색, 불안정한 서버</h2>
<p>300만 회원이 사용하는 커머스 플랫폼에서 검색은 핵심 기능입니다. 하지만 &quot;나이키 운동화&quot;를 검색하면 결과가 나오기까지 1~2초가 걸렸고, 키워드가 길어지면 훨씬 더 오래 걸렸습니다. 검색 후 상품을 클릭하는 비율(CTR)은 17%에 불과했습니다.</p>
<p>더 심각한 문제는 서버 안정성이었습니다. 검색을 위해 서버 메모리에 전체 상품 데이터를 올려놓는 구조였기 때문에, 상품 수가 증가할수록 서버 메모리와 CPU에 부담이 가중되었습니다. 검색 순위를 조정하려면 코드를 수정하고 프로덕션에 배포해야 했고, 마케팅팀의 요청 하나에도 30분이 소요되었습니다.</p>
<p>검색 엔진을 전면 개편하기로 결정했습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-fusejs의-한계">문제 분석: Fuse.js의 한계</h2>
<p>기존 시스템은 <strong>Fuse.js</strong>라는 JavaScript 기반 퍼지 검색 라이브러리를 사용했습니다. Fuse.js는 역 인덱스(inverted index) 없이 전체 데이터를 순회하며 문자열 유사도를 계산하는 방식으로 동작합니다. 이를 서버 메모리에 전체 상품 데이터를 로드한 후 검색을 수행하는 방식으로 사용하고 있었습니다.</p>
<h3 id="왜-문제였을까">왜 문제였을까?</h3>
<ol>
<li><p><strong>서버 자원 과다 사용</strong></p>
<ul>
<li>전체 상품 데이터(수만 건)를 서버 메모리에 상주시켜야 함</li>
<li>검색할 때마다 전체 데이터를 순회하며 유사도 계산 → CPU 스파이크 발생</li>
<li>검색 외 다른 API 응답 속도까지 저하되는 영향</li>
</ul>
</li>
<li><p><strong>상품 수 증가에 취약한 구조</strong></p>
<ul>
<li>역 인덱스가 없어 상품이 늘어날수록 검색 시간이 선형으로 증가</li>
<li>&quot;나이키 에어맥스 270 블랙 런닝화&quot; 같은 긴 검색어는 특히 느림</li>
<li>서버 메모리 부족으로 재시작이 빈번</li>
</ul>
</li>
<li><p><strong>비즈니스 민첩성 부족</strong></p>
<ul>
<li>검색 순위 조정 = 코드 수정 + 배포 (30분)</li>
<li>A/B 테스트 불가능</li>
<li>동의어 추가도 배포 필요</li>
</ul>
</li>
<li><p><strong>데이터 품질 오염</strong></p>
<ul>
<li>검색 정확도를 높이기 위해 상품명에 검색용 키워드를 강제로 부착</li>
<li>예: &quot;나이키 신발&quot; → &quot;나이키 신발 운동화 스니커즈 런닝화&quot;</li>
<li>사용자에게 보이는 상품명도 지저분해짐</li>
</ul>
</li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="해결-목표-무엇을-달성하려-했나">해결 목표: 무엇을 달성하려 했나</h2>
<h3 id="정량적-목표">정량적 목표</h3>
<ul>
<li><strong>응답 속도</strong>: 1~2초 → 100ms 이하</li>
<li><strong>CTR</strong>: 17% → 22% 이상 (30% 향상)</li>
<li><strong>비용</strong>: CloudSearch 대비 30% 절감</li>
</ul>
<h3 id="정성적-목표">정성적 목표</h3>
<ul>
<li>사용자 행동 데이터(클릭률)를 반영하여 CTR 향상</li>
<li>상품 수가 증가해도 대응 가능한 확장 가능 구조</li>
<li>배포 없이 검색 알고리즘을 조정할 수 있는 유연한 방식</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-opensearch를-선택한-이유">아키텍처 설계: OpenSearch를 선택한 이유</h2>
<h3 id="opensearch-vs-cloudsearch">OpenSearch vs CloudSearch</h3>
<p>AWS에는 두 가지 관리형 검색 서비스가 있습니다.</p>
<table>
<thead>
<tr>
<th>기준</th>
<th>CloudSearch</th>
<th>OpenSearch</th>
</tr>
</thead>
<tbody><tr>
<td><strong>기반 엔진</strong></td>
<td>Apache Solr</td>
<td>Elasticsearch 포크 (OpenSearch)</td>
</tr>
<tr>
<td><strong>커스텀 스코어링</strong></td>
<td>제한적 (표현식 기반)</td>
<td>Function Score Query로 자유로운 구현</td>
</tr>
<tr>
<td><strong>한국어 분석</strong></td>
<td>기본 토크나이저</td>
<td>Nori 형태소 분석기</td>
</tr>
<tr>
<td><strong>플러그인 확장</strong></td>
<td>미지원</td>
<td>커스텀 플러그인 지원</td>
</tr>
<tr>
<td><strong>스케일링</strong></td>
<td>자동</td>
<td>인스턴스/샤드 직접 제어</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>참고</strong>: Amazon CloudSearch는 현재 신규 고객에게 더 이상 제공되지 않으며, AWS는 OpenSearch Service로의 전환을 권장하고 있습니다.</p>
</blockquote>
<p><strong>OpenSearch를 선택한 이유:</strong></p>
<ul>
<li>CTR 기반 커스텀 스코어링(Function Score Query) 구현 가능</li>
<li>Nori 형태소 분석기로 한국어 검색 품질 확보</li>
<li>기존 AWS 인프라(Redshift, Lambda, S3)와 자연스러운 통합</li>
<li>동의어/사용자 사전을 플러그인으로 관리 가능</li>
</ul>
<h3 id="전체-아키텍처">전체 아키텍처</h3>
<p>검색은 <strong>메타데이터 조회</strong>(상품 수, 필터)와 <strong>상품 검색</strong>, 총 2회의 쿼리로 이루어집니다.</p>
<pre class="mermaid">graph TB
    A[사용자] -->|검색| B[NestJS API]
    B -->|메타데이터/할인/상단노출| C[Redis]
    B -->|상품 검색| D[OpenSearch]

    E[Athena/Redshift] -->|주간 CTR 집계| F[색인 배치]
    F -->|CTR 포함 색인| D

    G[관리자] -->|동의어/사전 수정| H[S3]
    H -->|트리거| I[Lambda]
    I -->|재색인| D</pre><p><strong>핵심 컴포넌트:</strong></p>
<ol>
<li><strong>NestJS API</strong>: 검색 요청 처리 및 비즈니스 로직</li>
<li><strong>Redis</strong>: 메타데이터(상품 수, 필터), 즉시할인 비용, 상단 노출 리스트 캐싱</li>
<li><strong>OpenSearch</strong>: 전문 검색 및 CTR 기반 랭킹</li>
<li><strong>Athena/Redshift</strong>: 주간 CTR 데이터 집계</li>
<li><strong>Lambda + S3</strong>: 동의어/사용자 사전 자동 업데이트</li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-ctr-기반-동적-랭킹">핵심 구현 1: CTR 기반 동적 랭킹</h2>
<h3 id="문제-검색-결과를-어떻게-정렬할-것인가">문제: 검색 결과를 어떻게 정렬할 것인가?</h3>
<p>초기에는 OpenSearch의 기본 BM25 스코어만 사용했습니다. 하지만 이는 텍스트 유사도만 고려할 뿐, 실제로 사용자가 선호하는 상품을 반영하지 못했습니다.</p>
<p>예를 들어, &quot;운동화&quot; 검색 시:</p>
<ul>
<li>상품 A: 상품명에 &quot;운동화&quot;가 3번 등장 → 높은 점수</li>
<li>상품 B: 상품명에 &quot;운동화&quot;가 1번만 등장 → 낮은 점수</li>
</ul>
<p>하지만 <strong>상품 B의 CTR이 25%</strong>, <strong>상품 A의 CTR은 5%</strong>라면 어떨까요? 사용자는 명백히 상품 B를 선호하는데, 검색 결과는 상품 A를 상위에 노출하고 있었습니다.</p>
<h3 id="해결-색인-시-ctr-데이터를-함께-저장">해결: 색인 시 CTR 데이터를 함께 저장</h3>
<p><strong>CTR(Click-Through Rate, 클릭률)</strong>을 검색 랭킹에 반영하기 위해, 상품 데이터를 색인할 때 CTR 정보를 함께 저장하는 방식을 채택했습니다.</p>
<p><strong>1단계: Athena/Redshift에서 주간 CTR 집계</strong></p>
<p>매일 새벽, Athena 또는 Redshift에서 최근 7일간의 상품별 CTR을 집계합니다.</p>
<pre><code class="language-sql">SELECT
  product_id,
  SUM(clicks)::FLOAT / SUM(impressions)::FLOAT AS ctr
FROM search_logs
WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY product_id
HAVING SUM(impressions) >= 100  -- 최소 노출 100회 이상</code></pre><p><strong>2단계: CTR을 포함하여 상품 데이터 색인</strong></p>
<p>집계된 CTR 데이터를 상품 정보와 함께 OpenSearch에 색인합니다. 이렇게 하면 검색 시 별도의 CTR 조회 없이, Function Score Query로 CTR을 랭킹에 바로 반영할 수 있습니다.</p>
<p><strong>3단계: 브랜드 가중치 적용</strong></p>
<p>브랜드 테이블의 <code>brand_score</code> 필드(1~5 등급)를 활용하여, 브랜드 신뢰도를 보조적으로 랭킹에 반영합니다.</p>
<h3 id="검증-ab-테스트">검증: A/B 테스트</h3>
<p>1주일간 세션 기반 A/B 테스트를 진행했습니다.</p>
<ul>
<li><strong>그룹 A (기존)</strong>: Fuse.js 기반 기존 검색 시스템</li>
<li><strong>그룹 B (개선)</strong>: OpenSearch + CTR 기반 랭킹 시스템</li>
</ul>
<p><strong>결과:</strong></p>
<ul>
<li>CTR: 17% → 22.5% (<strong>32% 향상</strong>, p &lt; 0.01)</li>
<li>상품 상세 페이지 진입율: 11.75% 증가</li>
<li>구매 전환율: 8.3% 증가</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-캐시-전략으로-응답-속도-개선">핵심 구현 2: 캐시 전략으로 응답 속도 개선</h2>
<h3 id="문제-검색-과정에서-부가-조회가-많다">문제: 검색 과정에서 부가 조회가 많다</h3>
<p>검색 요청 하나를 처리하려면 여러 단계를 거칩니다.</p>
<ol>
<li><strong>메타데이터 조회</strong>: 전체 상품 수, 필터 옵션 (OpenSearch)</li>
<li><strong>상품 검색</strong>: 실제 검색 결과 (OpenSearch)</li>
<li><strong>즉시할인 계산</strong>: 상품별 할인 비용 적용</li>
<li><strong>상단 노출 리스트</strong>: 프로모션 상품 우선 노출</li>
</ol>
<p>OpenSearch 전환으로 검색 자체는 300ms로 개선되었지만, 메타데이터 조회와 할인 계산 등 부가 작업까지 합치면 추가 개선 여지가 있었습니다.</p>
<h3 id="해결-redis-캐싱-1분-ttl">해결: Redis 캐싱 (1분 TTL)</h3>
<p>자주 변하지 않는 부가 데이터를 Redis에 1분 주기로 캐싱했습니다.</p>
<p><strong>캐싱 대상:</strong></p>
<table>
<thead>
<tr>
<th>캐싱 항목</th>
<th>설명</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>메타데이터</td>
<td>전체 상품 수, 필터 옵션</td>
<td>1분</td>
</tr>
<tr>
<td>즉시할인 비용</td>
<td>상품별 실시간 할인 적용 금액</td>
<td>1분</td>
</tr>
<tr>
<td>상단 노출 리스트</td>
<td>프로모션/우선 노출 상품 목록</td>
<td>1분</td>
</tr>
</tbody></table>
<pre><code class="language-typescript">async getSearchMetadata(category: string): Promise<SearchMetadata> {
  const cacheKey = `search:meta:${category}`;

  const cached = await this.redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  const metadata = await this.openSearch.getMetadata(category);
  await this.redis.setex(cacheKey, 60, JSON.stringify(metadata));  // TTL 60초

  return metadata;
}</code></pre><p>1분 TTL을 선택한 이유는, 상품 수나 필터 옵션, 할인 정보가 초 단위로 변하지 않으면서도 너무 오래된 데이터를 보여주지 않기 위한 균형점이었습니다.</p>
<h3 id="결과-응답-속도-50ms-달성">결과: 응답 속도 50ms 달성</h3>
<ul>
<li><strong>OpenSearch 전환</strong>: 1~2초 → 300ms</li>
<li><strong>Redis 캐싱 적용</strong>: 300ms → 50ms</li>
<li><strong>캐시 히트율</strong>: 75%</li>
</ul>
<p>메타데이터 조회를 캐시로 대체함으로써 OpenSearch 호출 횟수도 줄어, 인스턴스 비용을 $450에서 $315로 절감할 수 있었습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-3-배포-없이-검색-품질-개선">핵심 구현 3: 배포 없이 검색 품질 개선</h2>
<h3 id="문제-동의어-추가에-30분-걸린다">문제: 동의어 추가에 30분 걸린다</h3>
<p>사용자는 &quot;운동화&quot;를 검색하지만, 상품명에는 &quot;스니커즈&quot;라고 적혀있는 경우가 많습니다. 동의어와 사용자 사전을 관리해야 하는데, 기존에는 코드에 하드코딩되어 있어 수정할 때마다 배포가 필요했습니다.</p>
<pre><code class="language-typescript">const synonyms = {
  '운동화': ['스니커즈', '러닝화', '트레이닝화'],
  '가방': ['백팩', '배낭', '핸드백'],
  // ... 코드에 하드코딩
};</code></pre><p>마케팅팀이 &quot;이번 주부터 &#39;슬리퍼&#39; 검색 시 &#39;쪼리&#39;도 보여주세요&quot;라고 요청하면:</p>
<ol>
<li>개발자가 코드 수정</li>
<li>PR 생성 및 리뷰</li>
<li>프로덕션 배포</li>
<li><strong>총 소요 시간: 30분</strong></li>
</ol>
<h3 id="해결-어드민-s3-lambda-자동화">해결: 어드민 + S3 + Lambda 자동화</h3>
<p><strong>1단계: 어드민 페이지에서 동의어 및 사용자 사전 수정</strong></p>
<p>마케팅팀이 어드민 페이지에서 직접 동의어와 사용자 사전을 수정할 수 있도록 했습니다.</p>
<p><strong>2단계: TXT 파일로 S3 업로드</strong></p>
<p>수정된 동의어와 사전 데이터를 OpenSearch 형식의 TXT 파일로 변환하여 S3에 업로드합니다.</p>
<pre><code class="language-typescript">@Post('/admin/synonyms')
async updateSynonyms(@Body() dto: SynonymDto) {
  // 동의어를 OpenSearch 형식의 TXT로 변환
  const synonymText = dto.entries
    .map(e => `${e.word},${e.synonyms.join(',')}`)
    .join('\n');

  await this.s3.upload({
    Bucket: 'search-config',
    Key: 'synonyms.txt',
    Body: synonymText,
  });

  return { message: '동의어가 등록되었습니다. 5분 내 반영됩니다.' };
}</code></pre><p><strong>3단계: S3 이벤트 → Lambda → 재색인</strong></p>
<p>S3에 TXT 파일이 업로드되면 Lambda가 자동으로 트리거되어 OpenSearch를 재색인합니다.</p>
<pre><code class="language-typescript">export const handler = async (event: S3Event) => {
  // 1. S3에서 동의어/사전 TXT 다운로드
  const synonyms = await downloadFromS3(event);

  // 2. OpenSearch 동의어 필터 업데이트
  // 인덱스 close → 설정 변경 → open 순서로 무중단 반영
  await openSearch.indices.close({ index: 'products' });
  await openSearch.indices.putSettings({
    index: 'products',
    body: {
      settings: {
        analysis: {
          filter: {
            synonym_filter: {
              type: 'synonym',
              synonyms_path: 'synonyms.txt',
            },
          },
        },
      },
    },
  });
  await openSearch.indices.open({ index: 'products' });

  // 3. 재색인 (기존 문서에 새로운 동의어 적용)
  await openSearch.indices.updateByQuery({
    index: 'products',
    refresh: true,
  });
};</code></pre><h3 id="결과-30분-5분-6배-단축">결과: 30분 → 5분 (6배 단축)</h3>
<ul>
<li>마케팅팀이 어드민 페이지에서 동의어/사전 수정 (1분)</li>
<li>TXT 파일이 S3에 업로드되고 Lambda가 자동으로 재색인 (4분)</li>
<li><strong>총 소요 시간: 5분</strong></li>
<li><strong>개발자 개입: 0분</strong></li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="결과-숫자로-증명하는-개선-효과">결과: 숫자로 증명하는 개선 효과</h2>
<h3 id="정량적-성과">정량적 성과</h3>
<table>
<thead>
<tr>
<th>지표</th>
<th>Before</th>
<th>After</th>
<th>개선율</th>
</tr>
</thead>
<tbody><tr>
<td><strong>검색 응답 속도</strong></td>
<td>1~2초</td>
<td>50ms</td>
<td><strong>약 30배</strong></td>
</tr>
<tr>
<td><strong>CTR</strong></td>
<td>17%</td>
<td>22.5%</td>
<td><strong>32% 향상</strong></td>
</tr>
<tr>
<td><strong>상품 상세 페이지 진입율</strong></td>
<td>-</td>
<td>-</td>
<td><strong>11.75% 증가</strong></td>
</tr>
<tr>
<td><strong>월 비용</strong></td>
<td>$450</td>
<td>$315</td>
<td><strong>30% 절감</strong></td>
</tr>
<tr>
<td><strong>동의어 업데이트</strong></td>
<td>30분</td>
<td>5분</td>
<td><strong>6배 단축</strong></td>
</tr>
</tbody></table>
<h3 id="비즈니스-임팩트">비즈니스 임팩트</h3>
<ul>
<li><strong>서버 안정성 확보</strong>: 서버 메모리에 상품 데이터를 적재하지 않아 서버 지표가 안정적으로 개선</li>
<li><strong>매출 증가</strong>: 검색 기반 구매가 전체 매출의 45% 차지 (기존 32%)</li>
<li><strong>사용자 이탈률 감소</strong>: 검색 후 이탈률 28% → 15% (13%p 감소)</li>
<li><strong>운영 효율</strong>: 검색 관련 개발 요청 80% 감소 (마케팅팀 셀프 서비스)</li>
</ul>
<h3 id="기술적-성과">기술적 성과</h3>
<ul>
<li><strong>확장성</strong>: 상품 수 증가에도 검색 성능 유지 (OpenSearch의 분산 아키텍처)</li>
<li><strong>안정성</strong>: 서버 메모리 부담 제거로 서버 전체 안정성 향상</li>
<li><strong>유지보수성</strong>: 신규 랭킹 요소 추가 시 1일 작업 (기존 1주)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<h3 id="1-검색은-단순히-quot찾기quot가-아니다">1. 검색은 단순히 &quot;찾기&quot;가 아니다</h3>
<p>검색 엔진을 개선하면서 깨달은 점은, 검색이 단순히 데이터를 찾는 것이 아니라 <strong>사용자가 원하는 것을 예측하는 것</strong>이라는 점입니다. CTR 기반 랭킹은 사용자의 선택을 존중하는 방식이었고, 결과적으로 더 나은 사용자 경험으로 이어졌습니다.</p>
<h3 id="2-데이터-주도-의사결정의-중요성">2. 데이터 주도 의사결정의 중요성</h3>
<p>A/B 테스트 없이 &quot;이게 더 나을 것 같다&quot;는 직감만으로 개발했다면, CTR 32% 향상이라는 성과를 증명할 수 없었을 것입니다. 모든 주요 변경사항은 A/B 테스트로 검증했고, 이는 팀 내부 설득에도 큰 도움이 되었습니다.</p>
<h3 id="3-비용과-성능의-트레이드오프">3. 비용과 성능의 트레이드오프</h3>
<p>OpenSearch는 강력하지만 비용이 높습니다. Redis 캐싱으로 75%의 요청을 흡수함으로써 비용을 절감했습니다. 하지만 캐시 일관성, TTL 설정 등 고려할 점이 많았습니다. &quot;모든 문제를 캐싱으로 해결&quot;하는 것이 아니라, <strong>어디에 캐싱을 적용할지</strong> 선택하는 것이 중요했습니다.</p>
<h3 id="4-운영-자동화의-가치">4. 운영 자동화의 가치</h3>
<p>동의어 업데이트를 자동화함으로써, 개발팀은 더 중요한 문제에 집중할 수 있었습니다. &quot;30분 x 주 5회 = 월 10시간&quot;의 개발 시간을 절약했고, 이는 연간 120시간에 달합니다. 자동화는 단순히 시간 절약이 아니라, <strong>팀의 생산성과 만족도 향상</strong>으로 이어집니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="기술-스택">기술 스택</h2>
<ul>
<li><strong>검색 엔진</strong>: AWS OpenSearch Service</li>
<li><strong>백엔드</strong>: NestJS (TypeScript)</li>
<li><strong>캐시</strong>: Redis 6.x</li>
<li><strong>데이터 웨어하우스</strong>: Amazon Redshift, Athena</li>
<li><strong>자동화</strong>: AWS Lambda, S3</li>
<li><strong>모니터링</strong>: CloudWatch, Grafana</li>
</ul>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2025 Geunho Bang. Built with passion.</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#0366d6',
        primaryTextColor: '#24292e',
        primaryBorderColor: '#e1e4e8',
        lineColor: '#586069',
        secondaryColor: '#f6f8fa',
        tertiaryColor: '#fafbfc',
        background: '#ffffff',
        mainBkg: '#ffffff',
        secondBkg: '#f6f8fa',
        border1: '#e1e4e8',
        border2: '#e1e4e8',
        note: '#fff5b1',
        noteBkg: '#fff5b1',
        noteBorder: '#e1e4e8',
        noteText: '#24292e',
        fontSize: '14px',
        fontFamily: 'Inter, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
