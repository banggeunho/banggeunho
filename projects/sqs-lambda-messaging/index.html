<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SQS + Lambda 대량 문자 발송 시스템 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo"><span class="logo-name">bang</span><span class="logo-dot">.geunho</span></a>
    <ul class="nav-links">
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#skills">Skills</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="SQS + Lambda 대량 문자 발송 시스템">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>SQS + Lambda 대량 문자 발송 시스템</h1>
        
        <div class="project-detail-tags">
          
            <span>AWS SQS</span>
          
            <span>Lambda</span>
          
            <span>NestJS</span>
          
            <span>DLQ</span>
          
            <span>CloudWatch</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%EC%88%98%EB%8F%99-%EB%B0%9C%EC%86%A1%EC%9D%98-%ED%95%9C%EA%B3%84">배경: 수동 발송의 한계</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-%EC%99%9C-%EC%9E%90%EB%8F%99%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%96%88%EB%82%98">문제 분석: 왜 자동화가 필요했나</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%AA%A9%ED%91%9C-%EC%9A%B4%EC%98%81%ED%8C%80-%EC%85%80%ED%94%84-%EC%84%9C%EB%B9%84%EC%8A%A4">해결 목표: 운영팀 셀프 서비스</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-sqs--lambda-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0">아키텍처 설계: SQS + Lambda 선택 이유</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-%EC%96%B4%EB%93%9C%EB%AF%BC%EC%97%90%EC%84%9C-%EB%B0%9C%EC%86%A1-%EC%9A%94%EC%B2%AD">핵심 구현 1: 어드민에서 발송 요청</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-sqs--lambda-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC">핵심 구현 2: SQS + Lambda 비동기 처리</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-3-dlq-%EA%B8%B0%EB%B0%98-%EC%9E%90%EB%8F%99-%EC%9E%AC%EC%B2%98%EB%A6%AC">핵심 구현 3: DLQ 기반 자동 재처리</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-%EC%9B%94-100%EB%A7%8C-%EA%B1%B4-%EC%95%88%EC%A0%95-%EB%B0%9C%EC%86%A1">결과: 월 100만 건 안정 발송</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-수동-발송의-한계">배경: 수동 발송의 한계</h2>
<p>마케팅 캠페인, 주문 알림, 프로모션 안내 등 문자 발송은 커머스 서비스의 핵심 운영 수단입니다. 하지만 기존에는 <strong>문자 발송 시스템 자체가 존재하지 않았습니다.</strong></p>
<p><strong>기존 프로세스:</strong></p>
<pre><code class="language-">1. 운영팀이 개발팀에 대상 유저 데이터 추출 요청
2. 개발팀이 DB에서 직접 조회하여 유저 목록 전달
3. 운영팀이 엑셀로 정리
4. 문자 중개사 웹사이트에 엑셀 업로드
5. 대량 발송 실행</code></pre><p>모든 과정이 수동이었고, 발송 한 건에도 개발팀과 운영팀 양쪽의 시간이 소요되었습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-왜-자동화가-필요했나">문제 분석: 왜 자동화가 필요했나</h2>
<h3 id="1-개발팀-리소스-낭비">1. 개발팀 리소스 낭비</h3>
<p>문자 발송 요청이 올 때마다 개발자가 DB 쿼리를 작성하고 데이터를 추출해야 했습니다. 단순 반복 작업이지만 발송 조건이 매번 달라 완전한 자동화 없이는 사람이 개입해야 했습니다.</p>
<h3 id="2-발송-리드타임">2. 발송 리드타임</h3>
<p>운영팀 요청 → 개발팀 대응 → 데이터 추출 → 엑셀 정리 → 업로드까지 <strong>최소 반나절</strong>이 걸렸습니다. 긴급 발송이 필요한 상황에서도 이 과정을 거쳐야 했습니다.</p>
<h3 id="3-발송-실패-시-추적-불가">3. 발송 실패 시 추적 불가</h3>
<p>엑셀 기반 대량 발송은 개별 메시지의 성공/실패를 추적하기 어렵습니다. 어떤 유저에게 발송이 실패했는지, 재발송이 필요한지 확인할 방법이 없었습니다.</p>
<h3 id="4-발송-이력-관리-부재">4. 발송 이력 관리 부재</h3>
<p>누가, 언제, 어떤 조건으로, 몇 명에게 발송했는지 체계적으로 기록되지 않았습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="해결-목표-운영팀-셀프-서비스">해결 목표: 운영팀 셀프 서비스</h2>
<h3 id="정성적-목표">정성적 목표</h3>
<ul>
<li>운영팀이 어드민에서 직접 대상 선택 + 발송 실행</li>
<li>개발팀 개입 없이 발송 가능</li>
<li>발송 실패 자동 재처리</li>
<li>발송 이력 및 성공/실패 추적</li>
</ul>
<h3 id="정량적-목표">정량적 목표</h3>
<ul>
<li>월 100만 건 이상 안정 처리</li>
<li>API 서버 부하 없이 발송 처리</li>
<li>발송 실패율 최소화 (DLQ 기반 재처리)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-sqs-lambda-선택-이유">아키텍처 설계: SQS + Lambda 선택 이유</h2>
<h3 id="대안-비교">대안 비교</h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>별도 발송 서버 (EC2/ECS)</th>
<th>SQS + Lambda</th>
</tr>
</thead>
<tbody><tr>
<td>비용</td>
<td>상시 운영 비용</td>
<td>요청당 과금</td>
</tr>
<tr>
<td>확장성</td>
<td>수동 스케일링</td>
<td>자동 무한 확장</td>
</tr>
<tr>
<td>운영 부담</td>
<td>서버 관리 필요</td>
<td>완전 관리형</td>
</tr>
<tr>
<td>재처리</td>
<td>직접 구현 필요</td>
<td>DLQ 기본 제공</td>
</tr>
<tr>
<td>속도 제어</td>
<td>직접 구현</td>
<td>동시 실행 수로 제어</td>
</tr>
</tbody></table>
<p><strong>SQS + Lambda를 선택한 이유:</strong></p>
<ul>
<li>문자 발송은 상시 트래픽이 아니라 <strong>캠페인 시 집중되는 패턴</strong>이므로, 서버리스 종량제가 비용 효율적</li>
<li>SQS의 배치 처리 + Lambda의 동시 실행 수 제어로 문자 중개사의 rate limit에 맞춰 속도 조절 가능</li>
<li>DLQ 기본 제공으로 실패 재처리 인프라를 별도로 구축할 필요 없음</li>
<li>기존 AWS 인프라와 자연스러운 통합</li>
</ul>
<h3 id="전체-아키텍처">전체 아키텍처</h3>
<pre class="mermaid">graph TB
    A[운영팀] -->|대상 선택 + 발송| B[어드민 페이지]
    B -->|발송 요청| C[NestJS API]
    C -->|메시지 큐잉| D[SQS]
    D -->|배치 트리거| E[Lambda]
    E -->|벌크 API 호출| F[문자 중개사]
    F -->|발송 결과| E
    E -->|결과 저장| G[(MySQL)]

    D -.->|실패 3회| H[DLQ]
    H -->|알림| I[CloudWatch Alarm]
    I -->|Slack 알림| J[운영팀 확인]</pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-어드민에서-발송-요청">핵심 구현 1: 어드민에서 발송 요청</h2>
<h3 id="발송-api">발송 API</h3>
<p>운영팀이 어드민에서 대상 유저를 선택하고 메시지를 작성하면, API 서버가 대상 목록을 SQS에 전달합니다.</p>
<pre><code class="language-typescript">@Injectable()
export class MessagingService {
  constructor(
    private readonly sqsService: SqsService,
    private readonly messagingLogRepository: MessagingLogRepository,
  ) {}

  async sendBulkMessage(dto: BulkMessageDto) {
    const { userIds, content, templateId } = dto;

    // 1. 발송 로그 생성 (이력 관리)
    const log = await this.messagingLogRepository.create({
      totalCount: userIds.length,
      content,
      templateId,
      status: 'QUEUED',
    });

    // 2. SQS에 배치 단위로 전송 (최종 개선: sendMessageBatch)
    const chunks = this.chunkArray(userIds, 10);
    const batches = this.chunkArray(chunks, 10);

    for (const batch of batches) {
      await this.sqsService.sendMessageBatch({
        Entries: batch.map((chunk, i) =&gt; ({
          Id: `msg-${i}`,
          MessageBody: JSON.stringify({
            logId: log.id,
            userIds: chunk,
            content,
            templateId,
          }),
        })),
      });
    }

    return { logId: log.id, queuedCount: userIds.length };
  }

  private chunkArray&lt;T&gt;(array: T[], size: number): T[][] {
    return Array.from(
      { length: Math.ceil(array.length / size) },
      (_, i) =&gt; array.slice(i * size, (i + 1) * size),
    );
  }
}</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-sqs-lambda-비동기-처리">핵심 구현 2: SQS + Lambda 비동기 처리</h2>
<h3 id="lambda-핸들러">Lambda 핸들러</h3>
<p>SQS에서 메시지를 배치로 수신하여 문자 중개사의 벌크 API를 호출합니다. 멱등성 보장과 Rate Limit 대응이 핵심이며, 상세 구현은 아래 멱등성 섹션에서 설명합니다.</p>
<h3 id="rate-limit-대응">Rate Limit 대응</h3>
<p>문자 중개사가 벌크 API와 rate limit을 제공하므로, <strong>SQS 배치 사이즈와 Lambda 동시 실행 수를 rate limit에 맞춰 설정</strong>했습니다.</p>
<pre><code class="language-yaml">MessagingQueue:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: messaging-queue
    VisibilityTimeout: 120
    RedrivePolicy:
      deadLetterTargetArn: !GetAtt MessagingDLQ.Arn
      maxReceiveCount: 3

LambdaEventSourceMapping:
  Type: AWS::Lambda::EventSourceMapping
  Properties:
    EventSourceArn: !GetAtt MessagingQueue.Arn
    FunctionName: !Ref MessagingLambda
    BatchSize: 10
    MaximumConcurrency: 5  # 중개사 rate limit 내에서 처리</code></pre><ul>
<li><strong>BatchSize: 10</strong> — SQS에서 Lambda로 한 번에 전달하는 메시지 수</li>
<li><strong>MaximumConcurrency: 5</strong> — Lambda 동시 실행 수를 제한하여 중개사 rate limit 초과 방지</li>
<li><strong>VisibilityTimeout: 120</strong> — 처리 중인 메시지가 다른 Lambda에 중복 전달되지 않도록 충분한 시간 확보</li>
</ul>
<h3 id="멱등성idempotency-보장">멱등성(Idempotency) 보장</h3>
<p>SQS는 at-least-once delivery를 보장하므로, 동일한 메시지가 2번 이상 처리될 수 있습니다. 같은 유저에게 문자가 중복 발송되면 사용자 경험에 직접적인 악영향을 미치므로, <strong>발송 로그 기반 멱등성 체크</strong>를 적용했습니다.</p>
<pre><code class="language-typescript">export const handler = async (event: SQSEvent) =&gt; {
  for (const record of event.Records) {
    const payload = JSON.parse(record.body);
    const { logId, userIds, content, templateId } = payload;

    // 1. 유저 연락처 조회
    const users = await getUserPhoneNumbers(userIds);

    // 2. 이미 발송된 유저 필터링 (멱등성 체크)
    const alreadySent = await db('messaging_results')
      .whereIn('user_id', userIds)
      .where('log_id', logId)
      .where('status', 'SUCCESS')
      .pluck('user_id');

    const pendingUsers = users.filter(u =&gt; !alreadySent.includes(u.userId));

    if (pendingUsers.length === 0) {
      console.log(`All users already sent: logId=${logId}`);
      continue;
    }

    // 3. 미발송 유저에게만 발송
    const result = await smsProvider.sendBulk({
      recipients: pendingUsers.map(u =&gt; u.phoneNumber),
      content,
      templateId,
    });

    // 4. 발송 결과 저장
    await saveResults(logId, result);
  }
};</code></pre><p><code>(log_id, user_id)</code> 조합으로 이미 성공한 발송 건을 확인하고, 미발송 유저에게만 문자를 전송합니다. SQS 재시도로 같은 메시지가 다시 처리되어도 중복 발송이 발생하지 않습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="실무-이슈와-해결">실무 이슈와 해결</h2>
<h3 id="이슈-1-중개사-api-부분-성공">이슈 1: 중개사 API 부분 성공</h3>
<p><strong>문제:</strong> 벌크 API로 10명에게 발송 요청 시, 7명 성공 + 3명 실패가 발생하는 경우가 있었습니다. Lambda가 예외를 던지면 SQS가 전체 메시지를 재시도하게 되어, 이미 성공한 7명에게 중복 발송될 위험이 있었습니다.</p>
<p><strong>해결:</strong> 부분 성공 시 개별 결과를 DB에 기록하고, 실패한 유저만 별도 SQS 메시지로 재큐잉합니다. 위의 멱등성 체크와 결합하여, 재처리 시에도 성공한 유저는 건너뛰게 됩니다.</p>
<h3 id="이슈-2-visibilitytimeout과-처리-시간-불일치">이슈 2: VisibilityTimeout과 처리 시간 불일치</h3>
<p><strong>문제:</strong> 초기 VisibilityTimeout을 60초로 설정했으나, 대량 발송 시 중개사 API 응답이 느려 Lambda 처리 시간이 60초를 초과하는 경우가 발생했습니다. SQS가 메시지를 다시 visible 상태로 전환하여 다른 Lambda가 같은 메시지를 중복 처리했습니다.</p>
<p><strong>해결:</strong> VisibilityTimeout을 120초로 상향 조정했습니다. Lambda 최대 실행 시간(중개사 API 타임아웃 포함)의 2배 이상으로 설정하여 충분한 여유를 확보했습니다.</p>
<h3 id="이슈-3-대량-발송-시-sqs-큐잉-병목">이슈 3: 대량 발송 시 SQS 큐잉 병목</h3>
<p><strong>문제:</strong> 10만 건 발송 캠페인 시 API 서버에서 SQS로 메시지를 넣는 것 자체가 병목이 되었습니다. 10명씩 묶어 1만 개의 SQS 메시지를 개별 <code>sendMessage</code>로 전송하면 수 분이 소요되었습니다.</p>
<p><strong>해결:</strong> <code>sendMessageBatch</code>를 활용하여 최대 10개 메시지를 한 번의 API 호출로 전송합니다.</p>
<pre><code class="language-typescript">// 개별 전송 (느림): 10,000건 × 10ms = 100초
for (const chunk of chunks) {
  await this.sqs.sendMessage({ ... });
}

// 배치 전송 (빠름): 1,000번 × 10ms = 10초
const batches = this.chunkArray(chunks, 10);  // 10개씩 묶음
for (const batch of batches) {
  await this.sqs.sendMessageBatch({
    QueueUrl: process.env.MESSAGING_QUEUE_URL,
    Entries: batch.map((chunk, i) =&gt; ({
      Id: `msg-${i}`,
      MessageBody: JSON.stringify(chunk),
    })),
  });
}</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-3-dlq-기반-자동-재처리">핵심 구현 3: DLQ 기반 자동 재처리</h2>
<h3 id="실패-처리-흐름">실패 처리 흐름</h3>
<pre class="mermaid">graph LR
    A[SQS 메시지] -->|처리 시도| B{Lambda}
    B -->|성공| C[결과 저장]
    B -->|실패| D[SQS 재시도]
    D -->|1차 재시도| B
    D -->|2차 재시도| B
    D -->|3회 실패| E[DLQ]
    E -->|알림| F[CloudWatch Alarm]
    F -->|Slack| G[운영팀 확인]</pre><p>3회 재시도 후에도 실패한 메시지는 DLQ에 격리됩니다. DLQ 적재 메시지는 DLQ Consumer가 자동으로 재처리하고, 재처리에서도 실패하면 발송 이력을 <code>FAILED</code> 상태로 업데이트한 뒤 CloudWatch Alarm + Slack 알림을 전송합니다.</p>
<pre><code class="language-typescript">// DLQ Consumer (개념 예시)
async handleDlqMessage(message: Message) {
  try {
    await retrySend(message);
  } catch (error) {
    await this.messagingLogRepository.markFailed(message.logId, message.userIds);
    await this.alarmService.notifyDlqFailure(message, error);
  }
}</code></pre><pre><code class="language-yaml">MessagingDLQ:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: messaging-dlq
    MessageRetentionPeriod: 1209600  # 14일 보관

DLQAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: messaging-dlq-alarm
    MetricName: ApproximateNumberOfMessagesVisible
    Namespace: AWS/SQS
    Dimensions:
      - Name: QueueName
        Value: messaging-dlq
    Statistic: Sum
    Period: 300
    EvaluationPeriods: 1
    Threshold: 1
    ComparisonOperator: GreaterThanOrEqualToThreshold
    AlarmActions:
      - !Ref SlackNotificationTopic</code></pre><hr>
</section>
<section class="content-section">
<h2 id="결과-월-100만-건-안정-발송">결과: 월 100만 건 안정 발송</h2>
<h3 id="운영-프로세스-개선">운영 프로세스 개선</h3>
<table>
<thead>
<tr>
<th>단계</th>
<th>Before</th>
<th>After</th>
</tr>
</thead>
<tbody><tr>
<td>대상 추출</td>
<td>개발팀에 요청 (반나절)</td>
<td>어드민에서 직접 선택</td>
</tr>
<tr>
<td>발송 실행</td>
<td>엑셀 업로드</td>
<td>어드민에서 클릭</td>
</tr>
<tr>
<td>실패 추적</td>
<td>불가능</td>
<td>DLQ + 알림 자동화</td>
</tr>
<tr>
<td>이력 관리</td>
<td>없음</td>
<td>DB 자동 기록</td>
</tr>
<tr>
<td><strong>개발팀 개입</strong></td>
<td><strong>매번 필요</strong></td>
<td><strong>불필요</strong></td>
</tr>
</tbody></table>
<h3 id="기술적-성과">기술적 성과</h3>
<ul>
<li><strong>월 100만 건 이상</strong> 안정적으로 처리</li>
<li>API 서버 부하 완전 분리 — 발송 처리가 서비스 응답 속도에 영향을 주지 않음</li>
<li>DLQ 자동 재처리 + 최종 실패 상태 관리로 발송 누락 추적 가능</li>
<li>서버리스 구조로 캠페인 시 자동 확장, 평시에는 비용 거의 0원</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<h3 id="1-문제의-본질은-시스템-부재였다">1. 문제의 본질은 시스템 부재였다</h3>
<p>기존 문제는 &quot;동기 처리로 인한 서버 부하&quot;가 아니라, 애초에 <strong>발송 시스템 자체가 없어서 모든 과정이 수동</strong>이었다는 점입니다. 기술적 최적화보다 운영 프로세스 자동화가 더 큰 가치를 만들어냈습니다.</p>
<h3 id="2-서버리스는-불규칙-트래픽에-최적">2. 서버리스는 불규칙 트래픽에 최적</h3>
<p>문자 발송은 마케팅 캠페인 시 집중되고 평시에는 거의 없는 패턴입니다. EC2/ECS로 상시 운영했다면 대부분의 시간에 리소스가 낭비되었을 것입니다. SQS + Lambda의 종량제 모델이 이 패턴에 정확히 맞았습니다.</p>
<h3 id="3-rate-limit은-큐로-제어한다">3. Rate Limit은 큐로 제어한다</h3>
<p>외부 API의 rate limit을 애플리케이션 코드에서 제어하면 복잡해집니다. SQS의 배치 사이즈와 Lambda의 동시 실행 수를 조절하는 것만으로 인프라 레벨에서 깔끔하게 속도를 제어할 수 있었습니다.</p>
<h3 id="4-dlq는-선택이-아닌-필수">4. DLQ는 선택이 아닌 필수</h3>
<p>대량 발송에서 일부 실패는 불가피합니다. DLQ가 없었다면 실패한 메시지를 수동으로 추적해야 했을 것입니다. DLQ + CloudWatch Alarm + Slack 알림 조합으로 실패를 자동으로 감지하고 대응할 수 있는 체계를 갖추는 것이 중요했습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="기술-스택">기술 스택</h2>
<table>
<thead>
<tr>
<th>분류</th>
<th>기술</th>
</tr>
</thead>
<tbody><tr>
<td><strong>백엔드</strong></td>
<td>NestJS (TypeScript)</td>
</tr>
<tr>
<td><strong>메시지 큐</strong></td>
<td>AWS SQS + DLQ</td>
</tr>
<tr>
<td><strong>발송 처리</strong></td>
<td>AWS Lambda</td>
</tr>
<tr>
<td><strong>모니터링</strong></td>
<td>CloudWatch Alarm → Slack</td>
</tr>
<tr>
<td><strong>데이터베이스</strong></td>
<td>MySQL (발송 이력)</td>
</tr>
</tbody></table>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2026 Geunho Bang</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#22C55E',
        primaryTextColor: '#F8FAFC',
        primaryBorderColor: '#334155',
        lineColor: '#64748B',
        secondaryColor: '#1E293B',
        tertiaryColor: '#0F172A',
        background: '#0F172A',
        mainBkg: '#1E293B',
        secondBkg: '#334155',
        border1: '#334155',
        border2: '#475569',
        note: '#1E293B',
        noteBkg: '#1E293B',
        noteBorder: '#334155',
        noteText: '#F8FAFC',
        fontSize: '14px',
        fontFamily: 'IBM Plex Sans, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
