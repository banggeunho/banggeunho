<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>실시간 이미지 최적화 시스템 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo"><span class="logo-name">bang</span><span class="logo-dot">.geunho</span></a>
    <ul class="nav-links">
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#skills">Skills</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="실시간 이미지 최적화 시스템">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>실시간 이미지 최적화 시스템</h1>
        
        <div class="project-detail-tags">
          
            <span>Lambda@Edge</span>
          
            <span>CloudFront</span>
          
            <span>S3</span>
          
            <span>WebP</span>
          
            <span>AVIF</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%ED%8A%B8%EB%9E%98%ED%94%BD-30-%EC%A6%9D%EA%B0%80-%EB%B9%84%EC%9A%A9%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C">배경: 트래픽 30% 증가, 비용은 어떻게?</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-%EC%9B%90%EB%B3%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%84%9C%EB%B9%99%EC%9D%98-%EB%82%AD%EB%B9%84">문제 분석: 원본 이미지 서빙의 낭비</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%AA%A9%ED%91%9C-%EB%B9%84%EC%9A%A9-%EC%A0%88%EA%B0%90%EA%B3%BC-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0">해결 목표: 비용 절감과 속도 개선</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-lambdaedge-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0">아키텍처 설계: Lambda@Edge 선택 이유</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-cloudfront-functions%EB%A1%9C-%EC%96%B4%EB%B7%B0%EC%A7%95-%EB%B0%A9%EC%A7%80">핵심 구현 1: CloudFront Functions로 어뷰징 방지</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-lambdaedge%EB%A1%9C-on-demand-%EC%B2%98%EB%A6%AC">핵심 구현 2: Lambda@Edge로 On-demand 처리</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-3-%EC%BA%90%EC%8B%9C-%EB%AC%B4%ED%9A%A8%ED%99%94-%EC%A0%84%EB%9E%B5">핵심 구현 3: 캐시 무효화 전략</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-%EB%B9%84%EC%9A%A9-75-%EC%A0%88%EA%B0%90-%EC%86%8D%EB%8F%84-50-%EA%B0%9C%EC%84%A0">결과: 비용 75% 절감, 속도 50% 개선</a></li>
<li><a href="#%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85">트러블슈팅</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-트래픽-30-증가-비용은-어떻게">배경: 트래픽 30% 증가, 비용은 어떻게?</h2>
<p>에브리타임은 대학생 커뮤니티 앱입니다. 2024년 3월, 우리 커머스 서비스가 앱 내 전용 &#39;혜택탭&#39;으로 노출되기 시작했습니다.</p>
<img src="images/에브리타임_혜택탭이미지.png" alt="에브리타임 혜택탭" width="300">

<p><strong>변화의 규모:</strong></p>
<ul>
<li>거의 모든 페이지에 배너와 상품 이미지 노출</li>
<li>출시 후 트래픽 30% 급증</li>
<li>CloudFront 비용이 지속적으로 증가하는 추세</li>
</ul>
<p><strong>실제 CloudFront 비용 추이:</strong></p>
<pre><code class="language-">2024년 1월: 기준점
2024년 2월: 20% 증가
2024년 3-12월: 평균 유지
2025년 1월: 전년 대비 24.6% 추가 증가</code></pre><p>월별 데이터 전송량도 400GB에서 12,600GB까지 증가.</p>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-원본-이미지-서빙의-낭비">문제 분석: 원본 이미지 서빙의 낭비</h2>
<h3 id="기존-시스템의-문제">기존 시스템의 문제</h3>
<p><strong>1. 원본 이미지를 그대로 전송</strong></p>
<pre><code class="language-">- 업로드: 1920x1080 (300KB) 이미지
- 실제 사용: 400x300 크기로 리사이징해서 표시
- 전송: 300KB 전체를 다운로드 😱
- 낭비: 200KB (66%)</code></pre><p><strong>2. 서비스별 요구 크기가 제각각</strong></p>
<ul>
<li>썸네일: 200x200</li>
<li>리스트뷰: 400x300</li>
<li>상세페이지: 800x600</li>
<li>배너: 1200x400</li>
</ul>
<p>하지만 시스템은 모든 경우에 동일한 원본 이미지를 전송했습니다.</p>
<p><strong>3. 차세대 포맷 미지원</strong></p>
<pre><code class="language-">- JPEG (100KB)
- WebP (60KB) - 40% 절감
- AVIF (45KB) - 55% 절감</code></pre><p>JPEG만 지원했기 때문에 WebP, AVIF를 지원하는 모던 브라우저에서도 큰 파일을 다운로드했습니다.</p>
<h3 id="poc-실제-압축률-측정">PoC: 실제 압축률 측정</h3>
<p>실제 프로덕션 이미지로 측정한 결과:</p>
<p><strong>테스트 대상: 상품 상세 이미지 (442px 사용 중)</strong></p>
<ul>
<li>원본: JPEG, 35.1KB</li>
</ul>
<p><strong>포맷만 변경:</strong></p>
<pre><code class="language-">WebP: 9.9KB (71.7% 감소)
AVIF: 5.2KB (85.2% 감소)</code></pre><p><strong>포맷 + 사이즈 변경 (442px):</strong></p>
<pre><code class="language-">WebP: 5.4KB (84.6% 감소)
AVIF: 3.3KB (90.6% 감소)</code></pre><p><strong>결론:</strong> AVIF가 압축률은 최고지만, Opera Mini 등 일부 브라우저에서 미지원. WebP는 IE를 제외한 모든 브라우저에서 지원하므로 <strong>WebP를 기본으로 선택하되, <code>&lt;picture&gt;</code> 태그로 AVIF도 지원</strong>하는 방향을 채택했습니다.</p>
<p><strong>4. 클라이언트 단에서 크롭</strong></p>
<pre><code class="language-html">&lt;img src=&quot;original.jpg&quot; style=&quot;width: 200px; height: 200px; object-fit: cover;&quot;&gt;</code></pre><p>이미지는 300KB를 전부 다운로드하고, 브라우저에서 200x200으로 잘라서 표시. UX 저하 + 대역폭 낭비.</p>
<hr>
</section>
<section class="content-section">
<h2 id="해결-목표-비용-절감과-속도-개선">해결 목표: 비용 절감과 속도 개선</h2>
<h3 id="정량적-목표">정량적 목표</h3>
<ul>
<li><strong>CloudFront 비용</strong>: 50% 이상 절감</li>
<li><strong>페이지 로딩 속도</strong>: 50% 개선</li>
<li><strong>Lambda 타임아웃</strong>: 85% 감소 (20% → 3%)</li>
</ul>
<h3 id="정성적-목표">정성적 목표</h3>
<ul>
<li>On-demand 이미지 처리로 다양한 크기 요구사항 대응</li>
<li>차세대 포맷(WebP, AVIF) 자동 지원</li>
<li>악의적 요청 차단으로 비용 폭증 방지</li>
<li>기존 URL 구조 유지 (호환성 보장)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-lambdaedge-선택-이유">아키텍처 설계: Lambda@Edge 선택 이유</h2>
<h3 id="lambdaedge-vs-ec2-vs-ecs">Lambda@Edge vs EC2 vs ECS</h3>
<p>이미지 리사이징 시스템을 구축할 때 고려한 3가지 옵션:</p>
<table>
<thead>
<tr>
<th>기준</th>
<th>EC2/ECS</th>
<th>Lambda@Edge</th>
<th>S3 Pre-processing</th>
</tr>
</thead>
<tbody><tr>
<td>비용</td>
<td>상시 과금</td>
<td>요청당 과금</td>
<td>저장 공간 과다</td>
</tr>
<tr>
<td>확장성</td>
<td>수동 스케일링</td>
<td>자동 무한 확장</td>
<td>사전 생성 필요</td>
</tr>
<tr>
<td>지연시간</td>
<td>Origin까지 왕복</td>
<td>Edge에서 처리</td>
<td>빠름</td>
</tr>
<tr>
<td>유지보수</td>
<td>서버 관리 필요</td>
<td>완전 관리형</td>
<td>스크립트 관리</td>
</tr>
<tr>
<td>유연성</td>
<td>높음</td>
<td>중간</td>
<td>낮음</td>
</tr>
</tbody></table>
<p><strong>Lambda@Edge를 선택한 이유:</strong></p>
<ul>
<li><strong>비용 효율</strong>: 트래픽이 적을 때는 비용 거의 0원</li>
<li><strong>글로벌 배포</strong>: 전 세계 Edge Location에서 실행</li>
<li><strong>완전 관리형</strong>: 서버 관리 불필요</li>
<li><strong>캐시 통합</strong>: CloudFront와 네이티브 통합</li>
</ul>
<h3 id="전체-아키텍처">전체 아키텍처</h3>
<p><img src="images/Cloudfront_architecture.png" alt="이미지 최적화 아키텍처"></p>
<h3 id="요청-처리-흐름">요청 처리 흐름</h3>
<pre class="mermaid">sequenceDiagram
    participant Client as 브라우저
    participant CF_Func as CF Functions<br/>(Viewer Request)
    participant CF as CloudFront<br/>(캐시)
    participant Lambda as Lambda@Edge<br/>(Origin Response)
    participant S3 as S3

    Client->>CF_Func: ?w=387&h=287&f=webp&q=75
    CF_Func->>CF_Func: 검증 / 10px 올림 정규화 / 쿼리 정렬
    CF_Func->>CF: ?f=webp&h=290&q=80&w=390

    alt 캐시 HIT
        CF-->>Client: 캐시된 이미지 응답 (Lambda 실행 없음)
    else 캐시 MISS
        CF->>S3: 원본 이미지 요청
        S3-->>CF: 원본 이미지 반환
        CF->>Lambda: Origin Response 트리거
        Lambda->>Lambda: 이미지 리사이징 + 포맷 변환
        Lambda-->>CF: 최적화된 이미지
        CF->>CF: 캐시 저장
        CF-->>Client: 최적화된 이미지 응답
    end</pre><h3 id="이벤트-트리거-선택-이유">이벤트 트리거 선택 이유</h3>
<p>CloudFront는 4가지 이벤트 트리거를 제공합니다. 각 트리거의 실행 시점과 역할이 다르기 때문에, 비용과 기능 요구사항에 맞는 배치가 중요합니다.</p>
<table>
<thead>
<tr>
<th>트리거</th>
<th>실행 시점</th>
<th>실행 빈도</th>
<th>사용 가능 서비스</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Viewer Request</strong></td>
<td>요청 수신 직후 (캐시 확인 전)</td>
<td>모든 요청</td>
<td>CF Functions, Lambda@Edge</td>
</tr>
<tr>
<td>Viewer Response</td>
<td>응답 반환 직전</td>
<td>모든 요청</td>
<td>CF Functions, Lambda@Edge</td>
</tr>
<tr>
<td>Origin Request</td>
<td>캐시 MISS → Origin 전달 시</td>
<td>캐시 MISS만</td>
<td>Lambda@Edge</td>
</tr>
<tr>
<td><strong>Origin Response</strong></td>
<td>Origin 응답 수신 후 (캐시 저장 전)</td>
<td>캐시 MISS만</td>
<td>Lambda@Edge</td>
</tr>
</tbody></table>
<h3 id="url-파라미터-설계">URL 파라미터 설계</h3>
<pre><code class="language-">https://cdn.example.com/products/123.jpg?w=400&amp;h=300&amp;f=webp&amp;q=80

- w: width (너비)
- h: height (높이)
- f: format (webp, avif, jpg, png)
- q: quality (1-100, 기본 80)</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-cloudfront-functions로-어뷰징-방지">핵심 구현 1: CloudFront Functions로 어뷰징 방지</h2>
<h3 id="문제-악의적-요청으로-비용-폭증">문제: 악의적 요청으로 비용 폭증</h3>
<p>Lambda@Edge는 요청당 과금입니다. 악의적인 사용자가 다음과 같은 요청을 보내면?</p>
<pre><code class="language-">?w=1&amp;h=1    // 1x1 픽셀
?w=2&amp;h=2    // 2x2 픽셀
?w=3&amp;h=3    // 3x3 픽셀
...
?w=5000&amp;h=5000  // 5000x5000 픽셀</code></pre><p>각각 Lambda 실행 → 캐시되지 않음 → 비용 폭증 💸</p>
<h3 id="해결-cloudfront-functions로-검증정규화">해결: CloudFront Functions로 검증/정규화</h3>
<p>검증/정규화 로직은 Lambda@Edge에서도 구현할 수 있지만, <strong>CloudFront Functions를 별도로 분리</strong>했습니다.</p>
<table>
<thead>
<tr>
<th>기준</th>
<th>CloudFront Functions</th>
<th>Lambda@Edge</th>
</tr>
</thead>
<tbody><tr>
<td><strong>사용 가능 트리거</strong></td>
<td>Viewer Request/Response</td>
<td>4개 전부 (Viewer/Origin × Request/Response)</td>
</tr>
<tr>
<td><strong>실행 비용</strong></td>
<td>요청 100만 건당 $0.10</td>
<td>요청 100만 건당 $0.60</td>
</tr>
<tr>
<td><strong>실행 속도</strong></td>
<td>&lt; 1ms</td>
<td>5ms ~ 수 초</td>
</tr>
<tr>
<td><strong>제한</strong></td>
<td>네트워크/파일 I/O 불가, 최대 10KB</td>
<td>제한 없음</td>
</tr>
</tbody></table>
<p>Lambda@Edge도 Viewer Request에서 동일한 검증 로직을 실행할 수 있지만, 검증/정규화는 네트워크 I/O가 필요 없는 단순 연산이므로 CF Functions의 제한에 해당하지 않습니다. <strong>모든 요청에서 실행</strong>되는 Viewer Request 특성상, 비용이 1/6이고 속도가 10배 빠른 CF Functions가 적합합니다.</p>
<p>또한 정규화는 반드시 <strong>캐시 확인 전</strong>(Viewer Request)에 실행되어야 합니다. 만약 Origin Request에서 처리했다면, 정규화 전 쿼리로 캐시 키가 생성되어 동일한 이미지 요청도 캐시를 활용하지 못하게 됩니다.</p>
<p><strong>정규화 로직:</strong></p>
<pre><code class="language-javascript">function handler(event) {
  var params = event.request.querystring;

  // 1. w, h: 범위 제한(50~2000) + 10px 단위 올림
  //    예: w=387 → w=390, w=5000 → w=2000
  normalize(params.w, MIN=50, MAX=2000, STEP=10);
  normalize(params.h, MIN=50, MAX=2000, STEP=10);

  // 2. q: 품질 범위 제한(10~100) + 10단위 올림
  normalize(params.q, MIN=10, MAX=100, STEP=10);

  // 3. f: 허용 포맷만 통과 (jpeg, png, webp, avif, gif, svg)
  validateFormat(params.f);

  // 4. 쿼리 키 정렬 → 동일 파라미터 조합이 같은 캐시 키로 매핑
  //    ?w=390&amp;f=webp → ?f=webp&amp;w=390
  sortQueryString(params);

  return request;
}</code></pre><p><strong>효과:</strong></p>
<ul>
<li><code>?w=387&amp;h=287</code> → <code>?w=390&amp;h=290</code> (10px 단위 정규화)</li>
<li><code>?w=755</code> → <code>?w=760</code> (올림)</li>
<li>캐시 키 개수: 1,950개 → 195개 (<strong>10배 감소</strong>)</li>
</ul>
<p><strong>10px 단위 선택 이유:</strong></p>
<p>정규화 단위를 결정할 때 100px과 10px을 비교했습니다.</p>
<ul>
<li><strong>100px 단위의 한계</strong>: 서비스 요구사항 상 100px 단위로 떨어지지 않는 이미지가 다수 존재 (예: 썸네일 142px, 리스트뷰 342px, 배너 768px). 반올림 시 원본과 크기 차이가 눈에 띄는 경우 발생</li>
<li><strong>10px 단위 채택</strong>: 실제 서비스에서 10px 단위로 떨어지는 이미지 규격이 많아 자연스럽게 정확한 크기 매칭 가능</li>
<li>품질 저하 없이 캐시 효율을 확보하는 현실적인 균형점</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-lambdaedge로-on-demand-처리">핵심 구현 2: Lambda@Edge로 On-demand 처리</h2>
<p>이미지 리사이징과 포맷 변환은 Node.js 기반 이미지 처리 라이브러리인 <a href="https://github.com/lovell/sharp">Sharp</a>를 활용하여 구현했습니다.</p>
<pre><code class="language-typescript">import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import sharp from 'sharp';
import type { CloudFrontResponseEvent, CloudFrontResponseResult } from 'aws-lambda';

const s3 = new S3Client();

export const handler = async (event: CloudFrontResponseEvent): Promise&lt;CloudFrontResponseResult&gt; =&gt; {
  const response = event.Records[0].cf.response;
  const request = event.Records[0].cf.request;
  const params = new URLSearchParams(request.querystring);

  // 1. 원본 이미지 가져오기
  const key = request.uri.substring(1);
  const { Body } = await s3.send(new GetObjectCommand({
    Bucket: 'my-images-bucket',
    Key: key,
  }));
  const imageBuffer = Buffer.from(await Body!.transformToByteArray());

  // 2. 파라미터 파싱
  const width = parseInt(params.get('w') ?? '') || null;
  const height = parseInt(params.get('h') ?? '') || null;
  const format = params.get('f') ?? 'jpg';
  const quality = parseInt(params.get('q') ?? '') || 80;

  // 3. 이미지 처리
  let image = sharp(imageBuffer);

  if (width || height) {
    image = image.resize({
      width: width ?? undefined,
      height: height ?? undefined,
      fit: 'inside',           // 비율 유지
      withoutEnlargement: true, // 원본보다 크게 안 함
    });
  }

  // 포맷 변환
  const formatMap = { webp: 'webp', avif: 'avif', png: 'png' } as const;
  image = format in formatMap
    ? image[formatMap[format as keyof typeof formatMap]]({ quality })
    : image.jpeg({ quality });

  const buffer = await image.toBuffer();

  // 4. 응답 생성
  return {
    status: '200',
    headers: {
      'content-type': [{ key: 'Content-Type', value: `image/${format}` }],
      'cache-control': [{ key: 'Cache-Control', value: 'public, max-age=31536000' }],
      'content-length': [{ key: 'Content-Length', value: buffer.length.toString() }],
    },
    body: buffer.toString('base64'),
    bodyEncoding: 'base64',
  };
};</code></pre><h3 id="lambda-메모리-최적화">Lambda 메모리 최적화</h3>
<p>메모리를 단계별로 올려보면서 처리 속도와 비용의 최적점을 찾았습니다.</p>
<p><strong>메모리별 성능 비교:</strong></p>
<ul>
<li>512MB: 평균 5초, 타임아웃 빈번</li>
<li>1024MB: 평균 2초, 타임아웃 거의 없음</li>
<li>2048MB: 평균 1.8초, 성능 대비 비용 효율 낮음</li>
</ul>
<p><strong>비용 분석 예시:</strong></p>
<pre><code class="language-">512MB × 5초 = 2,500MB·초 (처리 느림, 타임아웃 발생)
1024MB × 2초 = 2,048MB·초 (더 빠르면서 비용도 유사)</code></pre><p><strong>선택: 1024MB</strong></p>
<ul>
<li>메모리를 2배로 늘렸지만 처리 시간이 2.5배 줄어 오히려 GB·초 기준 비용이 감소</li>
<li>타임아웃 85% 감소(20% → 3%)로 사용자 경험 대폭 개선</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-3-캐시-무효화-전략">핵심 구현 3: 캐시 무효화 전략</h2>
<p>캐싱을 도입할 때는 항상 무효화 전략도 함께 고려해야 합니다. 상품 이미지가 교체되면 CloudFront에 캐시된 리사이즈 이미지도 무효화해야 하기 때문입니다. 두 가지 방식을 비교했습니다.</p>
<p><strong>URL 버저닝 vs S3 이벤트 트리거:</strong></p>
<table>
<thead>
<tr>
<th>방식</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>URL 버저닝 (<code>?v=2</code>)</td>
<td>구현 단순</td>
<td>어드민/API 등 이미지 URL 참조하는 모든 곳 수정 필요</td>
</tr>
<tr>
<td><strong>S3 이벤트 트리거</strong></td>
<td>이미지 업로드 경로와 무관하게 중앙 처리</td>
<td>Lambda 추가 구현 필요</td>
</tr>
</tbody></table>
<p><strong>S3 이벤트 트리거 방식을 채택한 이유:</strong></p>
<p>어드민에서 이미지를 업로드하는 경로가 상품 등록, 배너 관리, 프로모션 관리 등 다양했습니다. 각 경로마다 URL 버저닝 로직을 추가하는 것보다, S3에 이미지가 업로드되는 이벤트를 감지하여 중앙에서 처리하는 것이 개발 공수 면에서 효율적이었습니다.</p>
<pre class="mermaid">sequenceDiagram
    participant Admin as 어드민
    participant S3 as S3
    participant Lambda as Lambda
    participant CF as CloudFront

    Admin->>S3: 이미지 업로드 (PutObject)
    S3->>Lambda: S3 Event 트리거
    Lambda->>CF: CreateInvalidation (캐시 무효화)
    CF->>CF: 해당 이미지 캐시 삭제

    Note over CF: 다음 요청 시<br/>Lambda@Edge가 재생성</pre><p>월 이미지 변경 건수가 100회 미만이므로 CloudFront Invalidation 무료 범위(월 1,000건) 내에서 운영 가능하며, 추가 비용이 발생하지 않습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="결과-비용-75-절감-속도-50-개선">결과: 비용 75% 절감, 속도 50% 개선</h2>
<p><img src="images/cloudfront_%EC%82%AC%EC%9A%A9%EB%9F%89_%EC%A7%80%ED%91%9C.png" alt="CloudFront 사용량 지표"></p>
<h3 id="비용-절감">비용 절감</h3>
<p>배포는 단계적으로 진행했습니다.</p>
<ol>
<li><strong>5월 15일</strong>: 혜택탭 전체 적용</li>
<li><strong>5월 20일</strong>: 상품 이미지, 배너 이미지 적용</li>
</ol>
<table>
<thead>
<tr>
<th>시점</th>
<th>요청 수</th>
<th>데이터 전송량</th>
<th>절감률</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4월 3일</strong> (적용 전)</td>
<td>360만 건</td>
<td>419.71GB</td>
<td>기준</td>
</tr>
<tr>
<td><strong>5월 26일</strong> (적용 후)</td>
<td>475만 건 (+31%)</td>
<td>132.49GB</td>
<td><strong>68%</strong></td>
</tr>
</tbody></table>
<p>요청이 115만 건(31%) 더 많았지만, 전송량은 오히려 <strong>약 3배 감소</strong>했습니다. 이미지 최적화가 없었다면 전송량 550GB로 예상되었으나 실제 132GB로 집계되었습니다.</p>
<p>CloudFront 데이터 전송 비용이 68% 감소했고, Lambda@Edge 실행 비용은 전체 대비 미미하여 <strong>총비용 기준 약 75% 절감</strong>으로 집계되었습니다.</p>
<h3 id="성능-개선">성능 개선</h3>
<table>
<thead>
<tr>
<th>지표</th>
<th>Before</th>
<th>After</th>
<th>개선률</th>
</tr>
</thead>
<tbody><tr>
<td><strong>평균 이미지 크기</strong></td>
<td>300KB</td>
<td>80KB</td>
<td>73%</td>
</tr>
<tr>
<td><strong>페이지 로딩 속도</strong></td>
<td>4.2초</td>
<td>2.1초</td>
<td>50%</td>
</tr>
<tr>
<td><strong>Lambda 타임아웃</strong></td>
<td>20%</td>
<td>3%</td>
<td>85% 감소</td>
</tr>
</tbody></table>
<p>상품 리스트 페이지 기준, 20개 상품 이미지 총 전송량이 6MB(JPEG 원본)에서 1.2MB(WebP 리사이징)로 줄어 로딩 속도가 4.2초에서 2.1초로 <strong>50% 개선</strong>되었습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="트러블슈팅">트러블슈팅</h2>
<p><strong>1. OOM (Out Of Memory) - 대용량 이미지</strong></p>
<table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td><strong>증상</strong></td>
<td>7952 × 5304 해상도 이미지 처리 시 Lambda OOM 발생</td>
</tr>
<tr>
<td><strong>원인</strong></td>
<td>Sharp 메모리 사용량: width × height × 4 바이트 = 약 160MB</td>
</tr>
<tr>
<td><strong>해결</strong></td>
<td>4000px 초과 이미지는 리사이징 건너뛰고 원본 반환</td>
</tr>
</tbody></table>
<p>2GB 메모리로 증설해도 초대형 이미지는 OOM이 발생하므로, 현실적인 제한선을 두는 것이 필요했습니다.</p>
<p><strong>2. Lambda 타임아웃 - 원본 응답 불가</strong></p>
<table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td><strong>증상</strong></td>
<td>처리 시간이 30초를 초과하면 응답 자체가 없음</td>
</tr>
<tr>
<td><strong>원인</strong></td>
<td>Lambda 자체가 종료되어 catch 블록도 실행 안 됨 → 원본 반환도 불가</td>
</tr>
<tr>
<td><strong>해결</strong></td>
<td><code>Promise.race</code>로 28초 타임아웃을 걸어 시간 초과 시 원본 이미지 반환</td>
</tr>
</tbody></table>
<p>CloudFront Lambda@Edge는 30초 제한이므로, 2초 여유를 두고 타임아웃을 설정했습니다.</p>
<p><strong>3. 확장자 없는 이미지 파일</strong></p>
<table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td><strong>증상</strong></td>
<td><code>product-image</code> 같은 확장자 없는 파일이 리사이징 대상에서 제외됨</td>
</tr>
<tr>
<td><strong>원인</strong></td>
<td>파일명의 확장자로 이미지 여부를 판단하는 로직</td>
</tr>
<tr>
<td><strong>해결</strong></td>
<td>S3 응답의 <code>Content-Type</code> 헤더로 이미지 여부 판단으로 변경</td>
</tr>
</tbody></table>
<hr>
</section>
<section class="content-section">
<h2 id="기술-스택">기술 스택</h2>
<table>
<thead>
<tr>
<th>분류</th>
<th>기술</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CDN</strong></td>
<td>CloudFront</td>
</tr>
<tr>
<td><strong>스토리지</strong></td>
<td>S3</td>
</tr>
<tr>
<td><strong>이미지 처리</strong></td>
<td>Lambda@Edge (Node.js 18, Sharp)</td>
</tr>
<tr>
<td><strong>요청 검증</strong></td>
<td>CloudFront Functions</td>
</tr>
</tbody></table>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2026 Geunho Bang</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#22C55E',
        primaryTextColor: '#F8FAFC',
        primaryBorderColor: '#334155',
        lineColor: '#64748B',
        secondaryColor: '#1E293B',
        tertiaryColor: '#0F172A',
        background: '#0F172A',
        mainBkg: '#1E293B',
        secondBkg: '#334155',
        border1: '#334155',
        border2: '#475569',
        note: '#1E293B',
        noteBkg: '#1E293B',
        noteBorder: '#334155',
        noteText: '#F8FAFC',
        actorBkg: '#1E293B',
        actorBorder: '#334155',
        actorTextColor: '#F8FAFC',
        actorLineColor: '#475569',
        signalColor: '#64748B',
        signalTextColor: '#F8FAFC',
        labelBoxBkgColor: '#0F172A',
        labelBoxBorderColor: '#334155',
        labelTextColor: '#94A3B8',
        loopTextColor: '#94A3B8',
        activationBorderColor: '#334155',
        activationBkgColor: '#0F172A',
        sequenceNumberColor: '#F8FAFC',
        fontSize: '14px',
        fontFamily: 'IBM Plex Sans, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
