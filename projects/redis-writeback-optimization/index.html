<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>배너 성과 집계 API 성능 최적화 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo">GB</a>
    <ul class="nav-links">
      <li><a href="../../index.html#about">About</a></li>
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#contact">Contact</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="배너 성과 집계 API 성능 최적화">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>배너 성과 집계 API 성능 최적화</h1>
        
        <div class="project-detail-tags">
          
            <span>Redis</span>
          
            <span>MySQL</span>
          
            <span>Lambda</span>
          
            <span>EventBridge</span>
          
            <span>Write-back</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%EC%9D%BC%EC%9D%BC-70%EB%A7%8C-%EA%B1%B4%EC%9D%98-%EB%B0%B0%EB%84%88-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%88%98%EC%A7%91">배경: 일일 70만 건의 배너 이벤트 수집</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-row-level-lock%EA%B3%BC-deadlock">문제 분석: Row-level Lock과 Deadlock</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88-%EA%B2%80%ED%86%A0-3%EA%B0%80%EC%A7%80-%EC%98%B5%EC%85%98-%EB%B9%84%EA%B5%90">해결 방안 검토: 3가지 옵션 비교</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-redis-write-back-%EC%A0%84%EB%9E%B5">아키텍처 설계: Redis Write-back 전략</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-redis-hash%EB%A1%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%A7%91%EA%B3%84">핵심 구현 1: Redis Hash로 실시간 집계</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-eventbridge--lambda-%EB%B0%B0%EC%B9%98-%EB%8F%99%EA%B8%B0%ED%99%94">핵심 구현 2: EventBridge + Lambda 배치 동기화</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-3-sqs-fallback%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9C%A0%EC%8B%A4-%EB%B0%A9%EC%A7%80">핵심 구현 3: SQS Fallback으로 데이터 유실 방지</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-db-%EB%B6%80%ED%95%98-10%EB%B0%B0-%EA%B0%90%EC%86%8C">결과: DB 부하 10배 감소</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-일일-70만-건의-배너-이벤트-수집">배경: 일일 70만 건의 배너 이벤트 수집</h2>
<p>에브리타임 혜택탭이 출시되면서 거의 모든 페이지에 프로모션 배너가 배치되었습니다. 배너가 노출되거나 클릭될 때마다 성과 집계 API가 호출되어, <strong>전체 API 중 호출량 1위</strong>를 기록하게 되었습니다.</p>
<p><strong>트래픽 규모:</strong></p>
<pre><code class="language-">- 일일 배너 이벤트(노출+클릭): 약 70만 건
- 초당 수~수십 건의 SQL UPDATE 발생</code></pre><p>매번 API 호출마다 MySQL DB에 직접 UPDATE 쿼리를 실행하는 구조였습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-row-level-lock과-deadlock">문제 분석: Row-level Lock과 Deadlock</h2>
<h3 id="기존-구조의-문제">기존 구조의 문제</h3>
<p><strong>배너 이벤트 발생 시 동작:</strong></p>
<pre><code class="language-javascript">router.post("/api/banner/performance/impression", async (req, res, next) => {
  const { bannerId } = req.body;
  const date = new Date();

  await usMapper.queryWithValues(`
    INSERT INTO banner_performance (banner_id, impression, click, date) VALUES (?)
    ON DUPLICATE KEY UPDATE impression = impression + 1
  `, [[bannerId, 1, 0, date]]);

  apiHandler.send(res, { success: true }, next);
});</code></pre><p><strong>문제점:</strong></p>
<p><strong>1. <code>INSERT ON DUPLICATE KEY UPDATE</code>의 Lock 경합</strong></p>
<p>이 구문은 단순 UPDATE와 달리, 먼저 Shared Lock(S)을 획득한 뒤 중복 키 감지 시 Exclusive Lock(X)으로 업그레이드하는 과정을 거칩니다. 같은 키(banner_id + date)에 동시 요청이 들어오면 Lock 대기가 발생합니다.</p>
<pre><code class="language-">요청 A: INSERT 시도 → S Lock 획득 → 중복 감지 → X Lock 대기
요청 B: INSERT 시도 → S Lock 획득 → 중복 감지 → X Lock 대기
요청 C: INSERT 시도 → S Lock 획득 → 중복 감지 → X Lock 대기</code></pre><p><strong>2. Deadlock 발생</strong></p>
<p>동시에 같은 키에 여러 요청이 <code>INSERT ON DUPLICATE KEY UPDATE</code>를 실행하면, S Lock → X Lock 업그레이드 과정에서 서로의 S Lock 해제를 기다리며 교착 상태가 발생합니다.</p>
<pre><code class="language-">트랜잭션 A: S Lock 획득 → X Lock 필요 (B의 S Lock 대기)
트랜잭션 B: S Lock 획득 → X Lock 필요 (A의 S Lock 대기)
→ Deadlock!</code></pre><p><strong>3. 다른 API에 대한 연쇄 영향</strong></p>
<p>배너 집계 API의 DB 부하로 인해 같은 RDS를 사용하는 다른 API들도 느려지는 현상이 발생했습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="해결-방안-검토-3가지-옵션-비교">해결 방안 검토: 3가지 옵션 비교</h2>
<h3 id="방안-1-데이터-구조-변경-row-insert">방안 1: 데이터 구조 변경 (Row INSERT)</h3>
<p>집계 테이블 UPDATE 대신 이벤트를 Row로 저장하는 방식입니다.</p>
<pre><code class="language-sql">-- 클릭 이벤트를 Row로 저장
INSERT INTO banner_clicks (banner_id, clicked_at) VALUES (1, NOW());

-- 집계는 별도 쿼리
SELECT COUNT(*) FROM banner_clicks WHERE banner_id = 1 AND clicked_at >= '2024-05-01';</code></pre><p><strong>불채택 이유:</strong></p>
<ul>
<li>데이터 적재량 증가로 인한 스토리지 비용 부담 (일일 70만 건 × 365일)</li>
<li>실시간 집계 쿼리(<code>COUNT</code>, <code>GROUP BY</code>)가 느림</li>
<li>개발 리소스 및 인프라 변경 비용이 높음</li>
</ul>
<h3 id="방안-2-메시지-큐-비동기-처리">방안 2: 메시지 큐 비동기 처리</h3>
<p>SQS 등 메시지 큐로 이벤트를 비동기 처리하는 방식입니다.</p>
<p><strong>불채택 이유:</strong></p>
<ul>
<li>운영 복잡도 증가</li>
<li>메시지 큐 인프라 추가 비용</li>
<li>결국 DB에 쓰는 구조는 동일하여 근본적 해결이 아님</li>
</ul>
<h3 id="방안-3-redis-집계-배치-동기화-채택">방안 3: Redis 집계 + 배치 동기화 (채택)</h3>
<p>Redis에서 실시간 집계 후 주기적으로 DB에 동기화하는 Write-back 방식입니다.</p>
<p><strong>채택 이유:</strong></p>
<ul>
<li>기존 ElastiCache 인프라를 그대로 활용 (추가 비용 없음)</li>
<li>성능, 비용, 안정성 모두 균형</li>
<li>DB 부하를 근본적으로 해소</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-redis-write-back-전략">아키텍처 설계: Redis Write-back 전략</h2>
<h3 id="전체-아키텍처">전체 아키텍처</h3>
<pre class="mermaid">graph TB
    A[배너 이벤트] --> B[API Server]
    B --> C[Redis HINCRBY]
    C -->|성공| D[즉시 응답]

    B -.Redis 실패.-> E[SQS Fallback]
    E --> F[SQS Consumer]
    F --> G[MySQL RDS]

    H[EventBridge Scheduler] -->|10분마다| I[AWS Lambda]
    I -->|SCAN으로 데이터 조회| C
    I -->|Bulk INSERT| G</pre><h3 id="배치-주기-일일-1회에서-10분으로-변경">배치 주기: 일일 1회에서 10분으로 변경</h3>
<p>초기에는 일일 1회(오전 6시, 트래픽 최소 시간대) 배치로 운영했습니다. 그러나 Redis 장애 발생 시 하루치 데이터가 유실될 위험이 있어, <strong>10분 주기로 변경</strong>했습니다.</p>
<table>
<thead>
<tr>
<th>주기</th>
<th>장점</th>
<th>단점</th>
<th>결정</th>
</tr>
</thead>
<tbody><tr>
<td>1분</td>
<td>데이터 유실 최소화</td>
<td>DB 부하 여전히 높음</td>
<td>❌</td>
</tr>
<tr>
<td><strong>10분</strong></td>
<td><strong>유실 위험 최소화 + DB 부하 감소</strong></td>
<td><strong>약간의 데이터 지연</strong></td>
<td><strong>✅</strong></td>
</tr>
<tr>
<td>1시간</td>
<td>DB 부하 크게 감소</td>
<td>유실 시 1시간 데이터 손실</td>
<td>❌</td>
</tr>
<tr>
<td>일일 1회</td>
<td>DB 부하 최소</td>
<td>장애 시 하루치 데이터 유실</td>
<td>❌ (기존)</td>
</tr>
</tbody></table>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-redis-hash로-실시간-집계">핵심 구현 1: Redis Hash로 실시간 집계</h2>
<h3 id="redis-hash-구조">Redis Hash 구조</h3>
<p>단순 카운터 누적 용도에는 인메모리 데이터 스토어가 적합합니다. 개별 String Key 대신 Hash Key로 통합하여 메모리를 최적화했습니다.</p>
<p><strong>데이터 모델:</strong></p>
<pre><code class="language-">Key: {date}:{banner_id}
Fields:
  - IMPRESSION: 노출 수
  - CLICK: 클릭 수
명령어: HINCRBY</code></pre><p><strong>예시:</strong></p>
<pre><code class="language-">20240501:1
  IMPRESSION: 12345
  CLICK: 890

20240501:2
  IMPRESSION: 8765
  CLICK: 432</code></pre><p>Redis는 싱글스레드로 동작하기 때문에 HINCRBY 명령어로 Lock 경합 없이 안정적으로 값을 누적할 수 있습니다. MySQL에서 발생하던 Row-level Lock과 Deadlock 문제가 원천적으로 해소됩니다.</p>
<h3 id="api-구현">API 구현</h3>
<p><strong>이벤트 카운트 증가:</strong></p>
<pre><code class="language-typescript">@Post('/banners/:id/click')
async incrementClick(@Param('id') bannerId: number) {
  const dateKey = dayjs().format('YYYYMMDD');

  try {
    // Redis HINCRBY (원자적 연산, Lock 없음)
    await this.redis.hincrby(
      `${dateKey}:${bannerId}`,
      'CLICK',
      1
    );
    return { success: true };

  } catch (error) {
    // Redis 실패 시 SQS Fallback
    await this.sqsService.sendMessage({
      type: 'BANNER_CLICK',
      bannerId,
      timestamp: Date.now()
    });
    return { success: true, fallback: true };
  }
}</code></pre><p><strong>실시간 조회:</strong></p>
<pre><code class="language-typescript">@Get('/banners/:id/stats')
async getStats(@Param('id') bannerId: number) {
  const dateKey = dayjs().format('YYYYMMDD');
  const stats = await this.redis.hgetall(`${dateKey}:${bannerId}`);

  return {
    impressions: parseInt(stats.IMPRESSION || '0'),
    clicks: parseInt(stats.CLICK || '0'),
    ctr: stats.IMPRESSION > 0
      ? (parseInt(stats.CLICK) / parseInt(stats.IMPRESSION) * 100).toFixed(2)
      : 0
  };
}</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-eventbridge-lambda-배치-동기화">핵심 구현 2: EventBridge + Lambda 배치 동기화</h2>
<h3 id="배치-아키텍처">배치 아키텍처</h3>
<p>EventBridge Scheduler가 10분마다 Lambda를 트리거하여 Redis 데이터를 RDS에 동기화합니다.</p>
<p><strong>Lambda 함수:</strong></p>
<pre><code class="language-typescript">export const handler = async () => {
  let cursor = '0';
  const statsData = [];

  // 1. SCAN으로 Redis 데이터 조회
  do {
    const [nextCursor, keys] = await redis.scan(
      cursor, 'MATCH', '*:*', 'COUNT', 100
    );
    cursor = nextCursor;

    for (const key of keys) {
      const [date, bannerId] = key.split(':');
      const stats = await redis.hgetall(key);

      if (stats.IMPRESSION || stats.CLICK) {
        statsData.push({
          date,
          bannerId: parseInt(bannerId),
          impressions: parseInt(stats.IMPRESSION || '0'),
          clicks: parseInt(stats.CLICK || '0'),
        });
      }
    }
  } while (cursor !== '0');

  if (statsData.length === 0) return;

  // 2. RDS에 Bulk INSERT
  await db.transaction(async (trx) => {
    await trx('banner_daily_stats')
      .insert(statsData)
      .onConflict(['date', 'banner_id'])
      .merge({
        impressions: trx.raw('banner_daily_stats.impressions + VALUES(impressions)'),
        clicks: trx.raw('banner_daily_stats.clicks + VALUES(clicks)'),
      });
  });

  // 3. 동기화 완료된 Redis 데이터 정리
  await cleanupOldRedisData(7); // 일주일 이상 된 데이터 삭제
};</code></pre><h3 id="scan을-사용하는-이유">SCAN을 사용하는 이유</h3>
<p><code>KEYS</code> 명령어는 전체 키를 한 번에 탐색하여 Redis를 블로킹합니다. 반면 <code>SCAN</code>은 반복적으로 점진 탐색을 수행하기 때문에, Redis의 싱글스레드 특성상 다른 요청을 차단하지 않고 부하를 최소화합니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-3-sqs-fallback으로-데이터-유실-방지">핵심 구현 3: SQS Fallback으로 데이터 유실 방지</h2>
<h3 id="redis-장애-시나리오">Redis 장애 시나리오</h3>
<ul>
<li>Redis 클러스터 재시작</li>
<li>네트워크 장애</li>
<li>메모리 부족 (OOM)</li>
</ul>
<p>이런 상황에서도 배너 성과 데이터를 유실하면 안 됩니다.</p>
<h3 id="sqs-fallback-메커니즘">SQS Fallback 메커니즘</h3>
<p><strong>API에서 SQS 전송:</strong></p>
<pre><code class="language-typescript">async incrementClick(bannerId: number) {
  try {
    // 1차: Redis 시도
    const dateKey = dayjs().format('YYYYMMDD');
    await this.redis.hincrby(`${dateKey}:${bannerId}`, 'CLICK', 1);
    return { success: true };

  } catch (error) {
    // 2차: SQS Fallback
    this.logger.warn(`Redis failed, fallback to SQS: ${bannerId}`);

    await this.sqs.sendMessage({
      QueueUrl: process.env.BANNER_STATS_QUEUE_URL,
      MessageBody: JSON.stringify({
        type: 'BANNER_CLICK',
        bannerId,
        timestamp: Date.now()
      })
    }).promise();

    return { success: true, fallback: true };
  }
}</code></pre><p><strong>SQS Consumer:</strong></p>
<pre><code class="language-typescript">@SqsMessageHandler('banner-stats-queue')
async handleMessage(message: Message) {
  const payload = JSON.parse(message.Body);

  // SQS 메시지는 DB에 직접 저장
  await this.db('banner_daily_stats')
    .where('banner_id', payload.bannerId)
    .increment('clicks', 1);
}</code></pre><p><strong>DLQ (Dead Letter Queue) 설정:</strong></p>
<pre><code class="language-yaml">BannerStatsQueue:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: banner-stats-queue
    VisibilityTimeout: 60
    RedrivePolicy:
      deadLetterTargetArn: !GetAtt BannerStatsDLQ.Arn
      maxReceiveCount: 3

BannerStatsDLQ:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: banner-stats-dlq
    MessageRetentionPeriod: 1209600  # 14일 보관</code></pre><hr>
</section>
<section class="content-section">
<h2 id="결과-db-부하-10배-감소">결과: DB 부하 10배 감소</h2>
<h3 id="성능-개선">성능 개선</h3>
<table>
<thead>
<tr>
<th>지표</th>
<th>개선 내용</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Write IOPS</strong></td>
<td>10배 이상 감소</td>
</tr>
<tr>
<td><strong>RDS CPU 사용률</strong></td>
<td>약 20% 감소</td>
</tr>
<tr>
<td><strong>EC2 CPU 사용률</strong></td>
<td>약 8% 감소</td>
</tr>
<tr>
<td><strong>Row-level Lock</strong></td>
<td>완전 해소</td>
</tr>
<tr>
<td><strong>Deadlock</strong></td>
<td>완전 해소</td>
</tr>
</tbody></table>
<p>ElastiCache 측은 CPU나 메모리 사용률에 유의미한 영향이 없었습니다. 단순 카운터 누적은 Redis에게 매우 가벼운 연산입니다.</p>
<h3 id="비용">비용</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>변경 내용</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ElastiCache</strong></td>
<td>기존 인프라 활용 (추가 비용 없음)</td>
</tr>
<tr>
<td><strong>EventBridge + Lambda</strong></td>
<td>월 $1 미만</td>
</tr>
<tr>
<td><strong>SQS</strong></td>
<td>Fallback 전용 (월 $0.5 미만)</td>
</tr>
</tbody></table>
<p>기존 인프라를 그대로 활용하면서 성능, 비용, 안정성 모두 개선할 수 있었습니다.</p>
<h3 id="다른-api-성능-회복">다른 API 성능 회복</h3>
<p>DB 부하가 감소하면서 같은 RDS를 사용하는 다른 API들의 응답 속도도 함께 개선되었습니다.</p>
<hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<p><strong>1. 단순 카운터에는 인메모리 스토어가 적합</strong></p>
<ul>
<li>MySQL의 UPDATE + Lock 구조는 고빈도 카운터에 부적합</li>
<li>Redis HINCRBY는 싱글스레드 특성으로 Lock 없이 원자적 처리</li>
</ul>
<p><strong>2. 배치 주기는 데이터 유실 리스크와 타협</strong></p>
<ul>
<li>일일 1회: DB 부하 최소지만 장애 시 하루치 유실 위험</li>
<li>10분: 유실 리스크와 DB 부하의 균형점</li>
<li>EventBridge + Lambda로 서버리스 배치 구현</li>
</ul>
<p><strong>3. SCAN은 프로덕션의 필수</strong></p>
<ul>
<li>KEYS 명령어는 Redis를 블로킹하여 서비스 장애 유발 가능</li>
<li>SCAN으로 점진 탐색하여 부하 최소화</li>
</ul>
<p><strong>4. Fallback 메커니즘은 필수</strong></p>
<ul>
<li>Redis 장애는 언제든 발생 가능</li>
<li>SQS + DLQ로 데이터 유실 방지</li>
<li>추가 비용은 거의 없음</li>
</ul>
<p><strong>5. Bulk INSERT의 효과</strong></p>
<ul>
<li>개별 INSERT 대비 DB 트랜잭션 횟수를 대폭 감소</li>
<li>10분간 누적된 데이터를 한 번의 트랜잭션으로 동기화</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="기술-스택">기술 스택</h2>
<table>
<thead>
<tr>
<th>분류</th>
<th>기술</th>
</tr>
</thead>
<tbody><tr>
<td><strong>캐시</strong></td>
<td>Redis (ElastiCache)</td>
</tr>
<tr>
<td><strong>데이터베이스</strong></td>
<td>MySQL (RDS)</td>
</tr>
<tr>
<td><strong>배치 스케줄러</strong></td>
<td>AWS EventBridge Scheduler</td>
</tr>
<tr>
<td><strong>배치 처리</strong></td>
<td>AWS Lambda</td>
</tr>
<tr>
<td><strong>Fallback</strong></td>
<td>AWS SQS + DLQ</td>
</tr>
</tbody></table>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2025 Geunho Bang. Built with passion.</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#0366d6',
        primaryTextColor: '#24292e',
        primaryBorderColor: '#e1e4e8',
        lineColor: '#586069',
        secondaryColor: '#f6f8fa',
        tertiaryColor: '#fafbfc',
        background: '#ffffff',
        mainBkg: '#ffffff',
        secondBkg: '#f6f8fa',
        border1: '#e1e4e8',
        border2: '#e1e4e8',
        note: '#fff5b1',
        noteBkg: '#fff5b1',
        noteBorder: '#e1e4e8',
        noteText: '#24292e',
        fontSize: '14px',
        fontFamily: 'Inter, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
