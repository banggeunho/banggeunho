<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>배너 성과 집계 API 성능 최적화 | Geunho Bang</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navigation -->
<nav class="nav scrolled" id="nav">
  <div class="nav-inner">
    <a href="../../index.html" class="nav-logo">GB</a>
    <ul class="nav-links">
      <li><a href="../../index.html#about">About</a></li>
      <li><a href="../../index.html#projects" class="active">Projects</a></li>
      <li><a href="../../index.html#contact">Contact</a></li>
    </ul>
    <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
      <span></span><span></span><span></span>
    </button>
  </div>
</nav>


  <main class="project-detail">
    <div class="container">

      <!-- Back -->
      <a href="../../index.html#projects" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5m0 0 7 7m-7-7 7-7"/></svg>
        Projects
      </a>

      <!-- Hero image -->
      
      <div class="project-detail-hero">
        <img src="images/thumbnail.svg" alt="배너 성과 집계 API 성능 최적화">
      </div>
      

      <!-- Header -->
      <div class="project-detail-header">
        <h1>배너 성과 집계 API 성능 최적화</h1>
        
        <div class="project-detail-tags">
          
            <span>Redis</span>
          
            <span>MySQL</span>
          
            <span>NestJS</span>
          
            <span>Write-back</span>
          
            <span>Performance</span>
          
        </div>
        
      </div>

      <!-- Content -->
      <div class="project-detail-content">
        <section class="content-section">
<h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%B0%B0%EA%B2%BD-%ED%95%98%EB%A3%A8-%EC%88%98%EB%B0%B1%EB%A7%8C-%EA%B1%B4%EC%9D%98-%EB%B0%B0%EB%84%88-%ED%81%B4%EB%A6%AD">배경: 하루 수백만 건의 배너 클릭</a></li>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D-db%EA%B0%80-%EB%B2%84%ED%8B%B0%EC%A7%80-%EB%AA%BB%ED%95%9C%EB%8B%A4">문제 분석: DB가 버티지 못한다</a></li>
<li><a href="#%ED%95%B4%EA%B2%B0-%EB%AA%A9%ED%91%9C-%EB%B6%80%ED%95%98-10%EB%B0%B0-%EA%B0%90%EC%86%8C-%EC%86%8D%EB%8F%84-50%EB%B0%B0-%EA%B0%9C%EC%84%A0">해결 목표: 부하 10배 감소, 속도 50배 개선</a></li>
<li><a href="#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84-write-back-%EC%A0%84%EB%9E%B5-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0">아키텍처 설계: Write-back 전략 선택 이유</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-1-redis-hash%EB%A1%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%A7%91%EA%B3%84">핵심 구현 1: Redis Hash로 실시간 집계</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-2-10%EB%B6%84-%EB%B0%B0%EC%B9%98%EB%A1%9C-db-%EB%8F%99%EA%B8%B0%ED%99%94">핵심 구현 2: 10분 배치로 DB 동기화</a></li>
<li><a href="#%ED%95%B5%EC%8B%AC-%EA%B5%AC%ED%98%84-3-sqs-fallback%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9C%A0%EC%8B%A4-%EB%B0%A9%EC%A7%80">핵심 구현 3: SQS Fallback으로 데이터 유실 방지</a></li>
<li><a href="#%EA%B2%B0%EA%B3%BC-db-%EB%B6%80%ED%95%98-10%EB%B0%B0-%EA%B0%90%EC%86%8C-%EC%9D%91%EB%8B%B5-%EC%86%8D%EB%8F%84-50%EB%B0%B0-%EA%B0%9C%EC%84%A0">결과: DB 부하 10배 감소, 응답 속도 50배 개선</a></li>
</ol>
<hr>
</section>
<section class="content-section">
<h2 id="배경-하루-수백만-건의-배너-클릭">배경: 하루 수백만 건의 배너 클릭</h2>
<p>에브리타임 혜택탭이 출시되면서 거의 모든 페이지에 프로모션 배너가 배치되었습니다. 배너가 노출될 때마다 성과 집계 API가 자동으로 호출되어, <strong>전체 API 중 호출량 1위</strong>를 기록하게 되었습니다.</p>
<p><strong>트래픽 규모:</strong></p>
<pre><code class="language-">- 일일 배너 노출: 300만 건
- 일일 배너 클릭: 50만 건
- 초당 평균 요청: 35 TPS
- 피크 시간대: 120 TPS</code></pre><p>그리고 매번 API 호출마다 MySQL DB에 UPDATE 쿼리를 실행했습니다.</p>
<p><strong>결과:</strong></p>
<ul>
<li>DB CPU 사용률 80% 이상 지속</li>
<li>API 응답 속도 평균 500ms (느림!)</li>
<li>다른 API들까지 느려지는 연쇄 효과</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="문제-분석-db가-버티지-못한다">문제 분석: DB가 버티지 못한다</h2>
<h3 id="기존-구조의-문제">기존 구조의 문제</h3>
<p><strong>배너 클릭 시 동작:</strong></p>
<pre><code class="language-typescript">async incrementClick(bannerId: number) {
  // DB에 직접 UPDATE
  await this.db.query(
    'UPDATE banner_stats SET clicks = clicks + 1 WHERE banner_id = ?',
    [bannerId]
  );
}</code></pre><p><strong>문제점:</strong></p>
<p><strong>1. UPDATE 쿼리의 비효율</strong></p>
<pre><code class="language-">- 매 요청마다 DB 트랜잭션 발생
- 테이블 Lock 발생 (다른 요청 대기)
- 디스크 I/O 발생 (WAL 쓰기)</code></pre><p><strong>2. DB IOPS 급증</strong></p>
<pre><code class="language-">CloudWatch 지표:
- Read IOPS: 1,000/sec (정상)
- Write IOPS: 5,000/sec (과부하!)
- CPU: 80% 이상 지속</code></pre><p><strong>3. 다른 API 영향</strong></p>
<pre><code class="language-">- 상품 조회 API: 100ms → 300ms
- 주문 생성 API: 200ms → 600ms
- DB 커넥션 풀 고갈</code></pre><h3 id="왜-row-insert-방식은-안-될까">왜 Row INSERT 방식은 안 될까?</h3>
<p>&quot;매번 UPDATE 대신 새로운 Row를 INSERT하면?&quot;</p>
<p><strong>고려했지만 불채택한 이유:</strong></p>
<pre><code class="language-sql">-- 클릭 이벤트를 Row로 저장
INSERT INTO banner_clicks (banner_id, clicked_at) VALUES (1, NOW());

-- 집계는 실시간 쿼리
SELECT COUNT(*) FROM banner_clicks WHERE banner_id = 1 AND clicked_at >= '2024-05-01';</code></pre><p><strong>문제점:</strong></p>
<ul>
<li>실시간 집계 쿼리(<code>SUM</code>, <code>GROUP BY</code>)가 UPDATE보다 3배 느림</li>
<li>파티셔닝을 적용해도 성능 개선 미미</li>
<li>스토리지 비용 급증 (일일 50만 건 × 365일)</li>
</ul>
<p><strong>벤치마크 결과 (50만 건 기준):</strong></p>
<pre><code class="language-">Row INSERT + COUNT(*) GROUP BY: 3.2초
UPDATE 집계 테이블: 1.1초
→ UPDATE 방식이 3배 빠름</code></pre><hr>
</section>
<section class="content-section">
<h2 id="해결-목표-부하-10배-감소-속도-50배-개선">해결 목표: 부하 10배 감소, 속도 50배 개선</h2>
<h3 id="정량적-목표">정량적 목표</h3>
<ul>
<li><strong>DB 부하</strong>: Write IOPS 10배 감소</li>
<li><strong>API 응답 속도</strong>: 500ms → 10ms (50배 개선)</li>
<li><strong>데이터 유실</strong>: 0건 (100% 보장)</li>
<li><strong>추가 비용</strong>: 0원 (기존 Redis 활용)</li>
</ul>
<h3 id="정성적-목표">정성적 목표</h3>
<ul>
<li>Redis 장애 시에도 데이터 유실 방지</li>
<li>다른 API의 성능 회복</li>
<li>실시간 집계 데이터 제공 (10분 지연 허용)</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="아키텍처-설계-write-back-전략-선택-이유">아키텍처 설계: Write-back 전략 선택 이유</h2>
<h3 id="write-through-vs-write-back">Write-through vs Write-back</h3>
<table>
<thead>
<tr>
<th>전략</th>
<th>Write-through</th>
<th>Write-back</th>
</tr>
</thead>
<tbody><tr>
<td><strong>쓰기 방식</strong></td>
<td>Redis + DB 동시 쓰기</td>
<td>Redis만 쓰기 → 배치로 DB 동기화</td>
</tr>
<tr>
<td><strong>API 응답 속도</strong></td>
<td>중간 (DB 대기)</td>
<td>매우 빠름 (Redis만)</td>
</tr>
<tr>
<td><strong>데이터 정합성</strong></td>
<td>즉시 일치</td>
<td>약간 지연 (10분)</td>
</tr>
<tr>
<td><strong>DB 부하</strong></td>
<td>높음</td>
<td>낮음</td>
</tr>
<tr>
<td><strong>적합한 경우</strong></td>
<td>금융 거래, 결제</td>
<td>통계, 집계, 로그</td>
</tr>
</tbody></table>
<p><strong>Write-back 선택 이유:</strong></p>
<ul>
<li>배너 성과 데이터는 10분 지연 허용 가능</li>
<li>DB 부하 감소가 최우선 목표</li>
<li>API 응답 속도 개선 필수</li>
</ul>
<h3 id="전체-아키텍처">전체 아키텍처</h3>
<pre class="mermaid">graph TB
    A[배너 클릭] --> B[API]
    B --> C[Redis HINCRBY]
    C -->|성공| D[응답 10ms]

    B -.실패.-> E[SQS Fallback]
    E --> F[SQS Consumer]
    F --> G[MySQL]

    H[배치 스케줄러] -->|10분마다| I[Redis 데이터 읽기]
    I --> J[Bulk INSERT]
    J --> G
    J -->|성공| K[Redis DEL]</pre><h3 id="배치-주기-선택-왜-10분">배치 주기 선택: 왜 10분?</h3>
<table>
<thead>
<tr>
<th>주기</th>
<th>장점</th>
<th>단점</th>
<th>결정</th>
</tr>
</thead>
<tbody><tr>
<td>1분</td>
<td>실시간에 가까움</td>
<td>DB 부하 여전히 높음</td>
<td>❌</td>
</tr>
<tr>
<td>10분</td>
<td>DB 부하 10배 감소</td>
<td>약간의 지연</td>
<td>✅</td>
</tr>
<tr>
<td>30분</td>
<td>DB 부하 30배 감소</td>
<td>데이터 유실 리스크</td>
<td>❌</td>
</tr>
<tr>
<td>1시간</td>
<td>최대 부하 감소</td>
<td>지연 시간 너무 김</td>
<td>❌</td>
</tr>
</tbody></table>
<p><strong>10분 선택 이유:</strong></p>
<ul>
<li>비즈니스 요구사항: 실시간성보다 성능 우선</li>
<li>데이터 분석팀: 10분 지연은 허용 가능</li>
<li>Redis 메모리: 10분 데이터는 1MB 이하</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-1-redis-hash로-실시간-집계">핵심 구현 1: Redis Hash로 실시간 집계</h2>
<h3 id="redis-hash-구조">Redis Hash 구조</h3>
<p><strong>데이터 모델:</strong></p>
<pre><code class="language-">Key: banner:stats:{bannerId}
Fields:
  - views: 노출 수
  - clicks: 클릭 수
  - updated_at: 최종 업데이트 시간</code></pre><p><strong>예시:</strong></p>
<pre><code class="language-">banner:stats:1
  views: 12345
  clicks: 890
  updated_at: 1714521600

banner:stats:2
  views: 8765
  clicks: 432
  updated_at: 1714521600</code></pre><h3 id="api-구현">API 구현</h3>
<p><strong>클릭 카운트 증가:</strong></p>
<pre><code class="language-typescript">@Post('/banners/:id/click')
async incrementClick(@Param('id') bannerId: number) {
  try {
    // Redis HINCRBY (원자적 연산)
    await this.redis.hincrby(
      `banner:stats:${bannerId}`,
      'clicks',
      1
    );

    // 최종 업데이트 시간 갱신
    await this.redis.hset(
      `banner:stats:${bannerId}`,
      'updated_at',
      Date.now()
    );

    return { success: true };

  } catch (error) {
    // Redis 실패 시 SQS Fallback
    await this.sqsService.sendMessage({
      type: 'BANNER_CLICK',
      bannerId: bannerId,
      timestamp: Date.now()
    });

    return { success: true, fallback: true };
  }
}</code></pre><p><strong>실시간 조회:</strong></p>
<pre><code class="language-typescript">@Get('/banners/:id/stats')
async getStats(@Param('id') bannerId: number) {
  // Redis에서 직접 조회 (10ms 이내)
  const stats = await this.redis.hgetall(`banner:stats:${bannerId}`);

  return {
    views: parseInt(stats.views || '0'),
    clicks: parseInt(stats.clicks || '0'),
    ctr: stats.views > 0
      ? (parseInt(stats.clicks) / parseInt(stats.views) * 100).toFixed(2)
      : 0
  };
}</code></pre><p><strong>성능:</strong></p>
<pre><code class="language-">Before (DB):
- API 응답 속도: 500ms
- TPS: 35 (DB 병목)

After (Redis):
- API 응답 속도: 10ms (50배 개선!)
- TPS: 1,000+ (제한 없음)</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-2-10분-배치로-db-동기화">핵심 구현 2: 10분 배치로 DB 동기화</h2>
<h3 id="배치-스케줄러">배치 스케줄러</h3>
<p><strong>NestJS Cron:</strong></p>
<pre><code class="language-typescript">@Injectable()
export class BannerSyncService {

  @Cron('*/10 * * * *')  // 10분마다 실행
  async syncToDatabase() {
    const startTime = Date.now();
    let syncCount = 0;

    try {
      // 1. Redis에서 모든 배너 통계 조회
      // 주의: 프로덕션에서는 SCAN 사용 (keys는 blocking 명령어)
      const keys = await this.redis.keys('banner:stats:*');

      // 2. 배치로 데이터 수집
      const statsData = [];
      for (const key of keys) {
        const bannerId = key.split(':')[2];
        const stats = await this.redis.hgetall(key);

        if (stats.clicks > 0 || stats.views > 0) {
          statsData.push({
            bannerId: parseInt(bannerId),
            views: parseInt(stats.views || '0'),
            clicks: parseInt(stats.clicks || '0'),
            syncedAt: new Date()
          });
        }
      }

      if (statsData.length === 0) {
        this.logger.log('No data to sync');
        return;
      }

      // 3. Bulk INSERT (트랜잭션 사용)
      await this.db.transaction(async (trx) => {
        // Bulk UPSERT
        await trx('banner_stats')
          .insert(statsData)
          .onConflict('banner_id')
          .merge({
            views: trx.raw('banner_stats.views + VALUES(views)'),
            clicks: trx.raw('banner_stats.clicks + VALUES(clicks)'),
            updated_at: new Date()
          });

        syncCount = statsData.length;
      });

      // 4. Redis 데이터 삭제 (임시 백업 후)
      const pipeline = this.redis.pipeline();
      for (const key of keys) {
        // 임시 백업 (1시간 TTL)
        await this.redis.rename(key, `${key}:backup`);
        await this.redis.expire(`${key}:backup`, 3600);
      }
      await pipeline.exec();

      const duration = Date.now() - startTime;
      this.logger.log(`Synced ${syncCount} banners in ${duration}ms`);

    } catch (error) {
      this.logger.error('Sync failed', error);

      // 5. 실패 시 Redis 복구
      await this.recoverRedisData();

      throw error;
    }
  }
}</code></pre><h3 id="트랜잭션-보장">트랜잭션 보장</h3>
<p><strong>배치 실행 플로우:</strong></p>
<pre><code class="language-">1. Redis 데이터 임시 백업
2. DB Bulk INSERT 시작
3-A. 성공 → Redis 백업 삭제
3-B. 실패 → Redis 백업 복구 → 재시도</code></pre><p><strong>데이터 유실 방지:</strong></p>
<pre><code class="language-typescript">async recoverRedisData() {
  // 백업된 데이터 복구
  const backupKeys = await this.redis.keys('banner:stats:*:backup');

  for (const backupKey of backupKeys) {
    const originalKey = backupKey.replace(':backup', '');
    await this.redis.rename(backupKey, originalKey);
  }

  this.logger.warn(`Recovered ${backupKeys.length} keys from backup`);
}</code></pre><hr>
</section>
<section class="content-section">
<h2 id="핵심-구현-3-sqs-fallback으로-데이터-유실-방지">핵심 구현 3: SQS Fallback으로 데이터 유실 방지</h2>
<h3 id="redis-장애-시나리오">Redis 장애 시나리오</h3>
<p><strong>문제:</strong></p>
<ul>
<li>Redis 클러스터 재시작</li>
<li>네트워크 장애</li>
<li>메모리 부족 (OOM)</li>
</ul>
<p>이런 상황에서도 데이터를 유실하면 안 됩니다.</p>
<h3 id="sqs-fallback-메커니즘">SQS Fallback 메커니즘</h3>
<p><strong>API에서 SQS 전송:</strong></p>
<pre><code class="language-typescript">async incrementClick(bannerId: number) {
  try {
    // 1차: Redis 시도
    await this.redis.hincrby(`banner:stats:${bannerId}`, 'clicks', 1);
    return { success: true };

  } catch (error) {
    // 2차: SQS Fallback
    this.logger.warn(`Redis failed, fallback to SQS: ${bannerId}`);

    await this.sqs.sendMessage({
      QueueUrl: process.env.BANNER_STATS_QUEUE_URL,
      MessageBody: JSON.stringify({
        type: 'BANNER_CLICK',
        bannerId: bannerId,
        timestamp: Date.now()
      })
    }).promise();

    return { success: true, fallback: true };
  }
}</code></pre><p><strong>SQS Consumer:</strong></p>
<pre><code class="language-typescript">@Injectable()
export class BannerStatsConsumer {

  @SqsMessageHandler('banner-stats-queue')
  async handleMessage(message: Message) {
    const payload = JSON.parse(message.Body);

    // SQS 메시지는 DB에 직접 저장
    await this.db('banner_stats')
      .where('banner_id', payload.bannerId)
      .increment('clicks', 1);

    this.logger.log(`Processed fallback click: ${payload.bannerId}`);
  }
}</code></pre><p><strong>DLQ (Dead Letter Queue) 설정:</strong></p>
<pre><code class="language-yaml"># SQS Queue 설정
BannerStatsQueue:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: banner-stats-queue
    VisibilityTimeout: 60
    RedrivePolicy:
      deadLetterTargetArn: !GetAtt BannerStatsDLQ.Arn
      maxReceiveCount: 3  # 3회 재시도 후 DLQ로 이동

BannerStatsDLQ:
  Type: AWS::SQS::Queue
  Properties:
    QueueName: banner-stats-dlq
    MessageRetentionPeriod: 1209600  # 14일 보관</code></pre><p><strong>결과:</strong></p>
<ul>
<li>Redis 장애 시에도 데이터 유실 0건</li>
<li>SQS로 자동 Fallback</li>
<li>DLQ로 실패 메시지 보관 및 수동 재처리</li>
</ul>
<hr>
</section>
<section class="content-section">
<h2 id="결과-db-부하-10배-감소-응답-속도-50배-개선">결과: DB 부하 10배 감소, 응답 속도 50배 개선</h2>
<h3 id="성능-개선">성능 개선</h3>
<table>
<thead>
<tr>
<th>지표</th>
<th>Before</th>
<th>After</th>
<th>개선률</th>
</tr>
</thead>
<tbody><tr>
<td><strong>API 응답 속도</strong></td>
<td>500ms</td>
<td>10ms</td>
<td><strong>50배 ⬇️</strong></td>
</tr>
<tr>
<td><strong>DB Write IOPS</strong></td>
<td>5,000/s</td>
<td>500/s</td>
<td><strong>10배 ⬇️</strong></td>
</tr>
<tr>
<td><strong>DB CPU 사용률</strong></td>
<td>80%</td>
<td>15%</td>
<td><strong>65%p ⬇️</strong></td>
</tr>
<tr>
<td><strong>최대 TPS</strong></td>
<td>35</td>
<td>1,000+</td>
<td><strong>28배 ⬆️</strong></td>
</tr>
</tbody></table>
<h3 id="비용-절감">비용 절감</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Before</th>
<th>After</th>
<th>비고</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RDS 인스턴스</strong></td>
<td>db.r5.large</td>
<td>db.r5.large</td>
<td>변경 없음</td>
</tr>
<tr>
<td><strong>Redis</strong></td>
<td>기존 클러스터</td>
<td>기존 클러스터</td>
<td><strong>추가 비용 0원</strong></td>
</tr>
<tr>
<td><strong>SQS</strong></td>
<td>-</td>
<td>$0.5/월</td>
<td>Fallback 전용</td>
</tr>
</tbody></table>
<p><strong>추가 인프라 비용: 거의 0원</strong> ✅</p>
<h3 id="다른-api-성능-회복">다른 API 성능 회복</h3>
<table>
<thead>
<tr>
<th>API</th>
<th>Before</th>
<th>After</th>
<th>개선률</th>
</tr>
</thead>
<tbody><tr>
<td><strong>상품 조회</strong></td>
<td>300ms</td>
<td>100ms</td>
<td>67% ⬇️</td>
</tr>
<tr>
<td><strong>주문 생성</strong></td>
<td>600ms</td>
<td>200ms</td>
<td>67% ⬇️</td>
</tr>
<tr>
<td><strong>DB 커넥션 풀</strong></td>
<td>95% 사용</td>
<td>20% 사용</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="데이터-정합성">데이터 정합성</h3>
<pre><code class="language-">- 배치 동기화: 10분마다 정상 실행
- Redis 장애: SQS Fallback 0건 유실
- 트랜잭션 실패: 자동 복구 100% 성공</code></pre><hr>
</section>
<section class="content-section">
<h2 id="배운-점">배운 점</h2>
<p><strong>1. Write-back은 통계/집계에 최적</strong></p>
<ul>
<li>실시간성이 중요하지 않은 데이터</li>
<li>대량의 쓰기 요청이 들어오는 경우</li>
<li>Redis만으로 10ms 이내 응답 가능</li>
</ul>
<p><strong>2. 배치 주기는 비즈니스와 타협</strong></p>
<ul>
<li>1분: DB 부하 여전히 높음</li>
<li>10분: 최적의 균형점</li>
<li>30분: 데이터 유실 리스크</li>
</ul>
<p><strong>3. Fallback 메커니즘은 필수</strong></p>
<ul>
<li>Redis 장애는 언제든 발생 가능</li>
<li>SQS + DLQ로 데이터 유실 방지</li>
<li>추가 비용은 거의 없음 (월 $0.5)</li>
</ul>
<p><strong>4. Bulk INSERT가 핵심</strong></p>
<pre><code class="language-sql">-- 단건 INSERT (느림)
INSERT INTO banner_stats (...) VALUES (...);  -- 10ms × 1000건 = 10초

-- Bulk INSERT (빠름)
INSERT INTO banner_stats (...) VALUES
  (...), (...), ...;  -- 100ms × 1번 = 100ms</code></pre><ul>
<li>100배 빠름!</li>
<li>트랜잭션 1번만 발생</li>
</ul>
<p><strong>5. Redis Hash는 집계에 완벽</strong></p>
<ul>
<li>HINCRBY는 원자적 연산 (Thread-safe)</li>
<li>TTL 설정으로 메모리 자동 관리</li>
<li>HGETALL로 빠른 조회</li>
</ul>
</section>

      </div>

    </div>
  </main>

  <footer class="footer">
  <div class="container">
    <p>&copy; 2025 Geunho Bang. Built with passion.</p>
  </div>
</footer>


  <script src="../../script.js"></script>

  <!-- Mermaid for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#0366d6',
        primaryTextColor: '#24292e',
        primaryBorderColor: '#e1e4e8',
        lineColor: '#586069',
        secondaryColor: '#f6f8fa',
        tertiaryColor: '#fafbfc',
        background: '#ffffff',
        mainBkg: '#ffffff',
        secondBkg: '#f6f8fa',
        border1: '#e1e4e8',
        border2: '#e1e4e8',
        note: '#fff5b1',
        noteBkg: '#fff5b1',
        noteBorder: '#e1e4e8',
        noteText: '#24292e',
        fontSize: '14px',
        fontFamily: 'Inter, -apple-system, sans-serif'
      }
    });
  </script>

  <!-- Prism for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
</body>
</html>
